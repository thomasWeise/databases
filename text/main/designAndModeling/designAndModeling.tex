\hsection{Database Design and Modeling}%
%
In the introductory factory example in the previous book part, we had some idea about how a \db\ should look like.
Then we just implemented it.
Of course, this is not how that works.
In the real world, \pglspl{db} are much more complicated.
There are not just three tables.
The interactions between objects, processes, and people are much more complex.
We now do have some rough idea about what kind of technological tools we have available to work with \pglspl{db}.
We have a good handle on the things that can be done and how they could be done.
But we have very little understanding of the practical process of \db\ design.
We do not yet know how we would realize a real \db\ project in a professional manner.

Imagine that we were people who want to build cars.
We know what wheels are and how they work.
We know what the battery does and how we can use it to make the motor run.
We know that normal people want to sit on seats inside the car and how to install seats.
We know what a chassis and a car body are, how they can be constructed, and how to put in the other parts.
Yet, we cannot really construct roadworthy vehicles yet.
Because this is not a puzzle game where we try to step-by-step plug parts into places where they fit until all the parts are included.
This involves a properly documented design process.
We need to first make a clear plan of what goes where and when to do what.
Only after the planning, the construction can begin.

Similarly, \pglspl{db} are designed in a methodical and systematic manner.
We start with an analysis of the requirements and step over increasingly precise models of our planned application.
This is what we want to learn in this part of the book.
At its core, the process of designing a \db\ will involve the creation of three models~(also called schemas)~\cite{EN2015FODS}: %
the conceptual model, the logical model, and the physical model.%
%
\begin{definition}[Conceptual Model]%
The \emph{conceptual model}~(or \emph{conceptual schema}) of a \db\ is a model of the real-world entities about which the system stores data as well as the relationships between them.%
\end{definition}%
%
The conceptual model is the high-level view on our application scenario.
The purpose of this model is to provide a clear concept of the application that is understandable by project stakeholders.
Such a model can be seen as a formalization of the the data-related part of the requirements.
It is also a vital part of the project documentation.
It is independent from any concrete data model or \db\ technology.
It represents entities, the attributes of entities, as well as the relationships among them.
%
\begin{definition}[Logical Model]%
\label{def:logicalModel}%
The \emph{logical model}~(or \emph{logical schema}) of a \db\ is a model of the data grounded to a specific type of technology~(e.g., \pglspl{rdb}, hierarchical \db, NoSQL~\db, \dots). %
It represents the entities, their attributes, and relationships as well as constraints using concrete datatypes and a structured, formal format.%
\end{definition}%
%
The logical model is the level on which the users and applications interact with the \db.
Here, the conceptual model is translated to a technical specification.
This model is often specified in a formal \db\ language like \sql.
It may be grounded to a specific \dbms\ or type of \dbms.%
%
\begin{definition}[Physical Model]%
The \emph{physical model}~(or \emph{physical schema} or \emph{internal schema}) is the specification of the concrete technological realization of the logical model. %
It is bound to a concrete \dbms\ and specifies exactly how the data is stored and accessed. %
The physical model impacts performance and system requirements, but not the way users and applications access the \db~(because that is defined by the logical model).%
\end{definition}%
%
In many smaller \db\ applications, the logical model can be used as physical model.
The logical model may be specified in a language like \sql.
In this case we have a clear definition how tables are created and accessed via queries and views.
From a \sqlil{CREATE TABLE}-command, for example, most normal \pglspl{dbms} can already infer proper default settings for storing the data.

However, to achieve high performance, the physical model can add further specifications:
How should large records be stored?
Should the data be sorted in any particular way?
Or should there be indexes, i.e., additional data structure for speeding up certain queries?

These specifications are invisible to the applications and users.
They access the \db\ by using, for example, \sql.
Their queries do not change in any way if the physical model changes.
However, the physical model has an impact on the query performance and the storage requirements of the data.
For larger \pglspl{db}, this can make a huge difference.

To a good share, the \db\ design process is concerned with getting these models correct.
There are different challenges at each step, from discussing with the future users to fine-tuning a \dbms.
We will explore these steps on a second example.
We will look a bit more closely at the process and the steps involved in creating a reasonably elaborate \db\ application.
As overarching example, we want to design a \db\ for managing students, teachers, and courses in a university.%
%
%
\hinput{lifecycle}{lifecycle.tex}%
\hinput{requirements}{requirements.tex}%
\hinput{conceptualSchema}{conceptualSchema.tex}%
\hinput{logicalSchema}{logicalSchema.tex}%
%
\endhsection%
%
