\hsection{Summary}%
%
At this point, we finish our excursion into the exciting world of conceptual modeling.
This important stage of the \db\ development lifecycle is somewhat the transition from requirements gathering to system implementation.
Here, we try to convert the requirements into semi-formal system models.
We can still discuss and verify them with stakeholders.

Conceptual models are supposed to be abstract.
They are not focused on any specific \db\ technology and do not even have to comply with the relational data model.
Instead, we try to represent the part of the world that is relevant for the system that we want to construct as clearly as possible.

The conceptual model for our example, the teaching management platform, is still relatively simple.
Yet, it already involves relationships between data over several levels indirection.
It already involves lots of different entity types.
Conceptual models of non-trivial systems have a certain complexity.

And this is also why we need them:
Of course, we could have started designing the \db\ with \sql\ right away.
That could even succeed.

However, this would have short-circuited our creative process.
When you read this part of the book from beginning to end in one go, you may notice that we changed the way we modeled certain things.
We could do that because we could look at simple visual representations of our \db.
We even (imagined that we) discussed them with our (imaginary) stakeholders in our (imaginary) university and incorporated (imaginary) feedback.
If you have downloaded \yEd\ and maybe even loaded the \pglspl{ERD} that we designed with it, you may have found that working with this tool to design a model is even {\dots} kind of fun.
At least I found that.
And I did not expect that it would be fun.%
%
\endhsection%
%
