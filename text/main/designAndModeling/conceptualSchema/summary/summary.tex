\hsection{Summary}%
%
At this point, we finish our excursion into the exciting world of conceptual modeling.
This important stage of the \db\ development lifecycle is somewhat the transition from requirements gathering to system implementation.
Here, we try to convert the requirements into semi-formal system models.
We can still discuss and verify them with stakeholders.

Conceptual models are supposed to be abstract.
They are not focused on any specific \db\ technology and do not even have to comply with the relational data model.
Instead, we try to represent the part of the world that is relevant for the system that we want to construct as clearly as possible.
This gives us more freedom.
We can model things in the most natural way and do not (yet) need to worry about how to actually implement the model.

At this stage, we can also hash out some basic principles for our system.


The conceptual model for our example, the teaching management platform, is still relatively simple.
Yet, it already involves relationships between data over several levels indirection.
It already involves lots of different entity types.
Conceptual models of non-trivial systems have a certain complexity.

And this is also why we need them:
Of course, we could have started designing the \db\ with \sql\ right away.
That could even succeed.

However, this would have short-circuited our creative process.
When you read this part of the book from beginning to end in one go, you may notice that we changed the way we modeled certain things.
We could do that because we could look at simple visual representations of our \db.
We even (imagined that we) discussed them with our (imaginary) stakeholders in our (imaginary) university and incorporated (imaginary) feedback.
If you have downloaded \yEd\ and maybe even loaded the \pglspl{ERD} that we designed with it, you may have found that working with this tool to design a model is even {\dots} kind of fun.
At least I found that.
And I did not expect that it would be fun.
Either way, it is clear that with relatively little effort, we can design a model or a part of a model as \pgls{ERD}.
When we find the something is wrong with the idea, or maybe we get an idea to achieve the same resuls with a simpler approach, then we can conveniently change the model.
Try doing that with a model based on \sql\ commands.%
%
\endhsection%
%
