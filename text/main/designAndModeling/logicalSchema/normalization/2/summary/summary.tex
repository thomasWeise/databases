\hsection{Summary}%
The \pgls{2NF} is a rule that helps us to avoid redundancy.
It prescribes that there should not be a functional dependency from non-key attributes on a part of any composite key.
As the result, it reduces the chance of errors during data entry, because the volume of data entered becomes smaller.

The \pgls{2NF} also mitigates problems that can be caused by deletion and update anomalies.
It comes at the cost of slightly more complicated queries:
To implement the \pgls{2NF} often means to divide the data into more tables.
Hence, when we need all of the information together, we need to merge it from these separate tables again using, e.g., \sqlilIdx{INNER JOIN} queries.

At the beginning of this section,  we were talking about \emph{keys}, but not just \emph{primary keys}.
We even gave the rather complicated \dref{def:2nf}, involving keys, the primary key, and super keys.
This looked all quite complicated for a rather simple statement, namely that no attribute can depend on a part of a key only.

The reason for this complicated formulation is that a relation can have multiple different keys.
Let's say we want to store information about people in table.
Then a reasonable key of such a table would be the government-issued ID number.
The name, place of birth, and \pgls{dateOfBirth} could be another key~(although this would be a slightly more dangerous choice, because two people of the same name could be born in the same place on the same day).
Yet another key could be the primary mobile phone number.
Maybe the best choice in a practical \db\ implementation would be to use a surrogate key, i.e., an identifier
that is unique and automatically generated by the \dbms.
This last possible choice is interesting and relevant here.

We presented a design of the room planning subsystem of our imaginary teaching management platform that violated the \pgls{2NF}.
We put all the data of rooms and buildings into a single table.
The primary key was composed of the building number and room number.
The columns for building name and building address only depend on the building number, but not on the room number.
This was the violation of the \pgls{2NF}.
We normalized the design to comply with the \pgls{2NF} by separating these columns into a new table.

If the \pgls{2NF} would only consider \emph{primary keys}, then another \inQuotes{solution} to this problem would be to simply use a surrogate key for our original table~\sqlil{building_room}.
Since the surrogate key would be a single column, the \pgls{2NF} would then no longer be violated.
If you refer back to our example and think about this method, you quickly realize:
This would have solved none of the problems of the design.
The deletion and update anomalies would have remained.

So having a definition for the \pgls{2NF} that can easily be implemented making a useless change to the design that leads to no improvement at all would be useless.
\Pglspl{NF} are defined exactly with the goal to give us guidance towards good \db\ design.
Observing them should yield a good structure and reduce the chance of anomalies.

For this purpose, the \pgls{2NF} concerns \emph{all key} attributes, not just the \emph{primary key} attributes.
Therefore, using a surrogate key would \emph{not} lead to a normalization under the \pgls{2NF}.
The building number/room number attribute combination would still be key for the table.
And the building name and building address would still only depend on a part of that key.%
\endhsection%
