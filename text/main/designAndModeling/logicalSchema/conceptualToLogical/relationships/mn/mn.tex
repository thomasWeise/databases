%
\hsection{\crowsFoot{M}{M1}{N}{MM}}%
\label{sec:rm:mn}%
%
\gitSQLAndOutput{\databasesCodeRepo}{conceptualToRelational}{MN_tables.sql}{relationships}{}{}{postgres.sh}{MN_tables}{%
The realization of a \crowsFoot{M}{M1}{N}{MM} conceptual relationship.%
}%
\gitSQLAndOutput{\databasesCodeRepo}{conceptualToRelational}{MN_insert_and_select.sql}{relationships}{}{}{postgres.sh}{MN_insert_and_select}{%
Inserting into and selecting data from the realization of an \crowsFoot{M}{M1}{N}{MM} conceptual relationship given in \cref{lst:MN_tables}.%
}%
%
We have the two entity types~M and~N.
Each entity of type~M must be linked to at least one entity of type~N, but can also be linked to many of them.
Each entity of type~N is connected to exactly one entity of type~M.

Implementing the referential integrity of this relationship pattern in \sql\ is a bit complicated but doable.
I did struggle with the \crowsFoot{G}{O1}{H}{MM} relationship pattern back in \cref{sec:rm:gh}, but in the end we figured it out.
A very similar pattern can be implemented now.

Creating the constraints for the referential integrity is not harder than in the case of the \crowsFoot{G}{O1}{H}{MM} relationship pattern from \cref{sec:rm:gh}.
We only have one more constraint, namely the one that enforces that entities of type~N are linked to entities of type~M.
And this additional constraint is the same that we used back then, just \inQuotes{the other way around.}
Writing down the table structures and constraints as shown in \cref{lst:MN_tables} can thus be understood once we comprehend \cref{lst:GH_tables} from back in \cref{sec:rm:gh}.

We create a table~\sqlil{m} for the entities of type~M.
This also needs an attribute~\sqlil{n} that will later be used to reference one row in table~\sqlil{n}.
And we create this table~\sqlil{n} for storing entities of type~N right away.
Since each row in~\sqlil{n} must be related to exactly one row in~\sqlil{m}, we also add a column~\sqlil{m} to this table that will reference the primary key of table~\sqlil{m}.
This neatly illustrates the chicken-and-egg problem.

But that pattern was easier because the \inQuotes{G~end} of the relationship was \inQuotes{optionally one}.
Once we had created the tables and constraints, we could begin storing data by \emph{first} populating the table for the entities of type~H.
Then we could take of creating the records for the table for the entities of type~G and fix the referential integrity.

Regardless of how we look at it, we do not have such luck this time:
Each entity of type~N \emph{must} be linked to exactly one existing entity of type~M.
Each entity of type~M \emph{must} be linked to at least one existing entity of type~N.
This is a much worse problem, because we need to know the primary key~\sqlil{nid} of a row in table~\sqlil{n} in order to create a new row in table~\sqlil{m} and we need to know the primary key~\sqlil{mid} of a row in table~\sqlil{m} to create a new row in table~\sqlil{n}.
%
\FloatBarrier%
\endhsection%
%
