%
\hsection{Summary}%
%
With this, we have reached the end of our simple introductory example.

What did we learn?
First of all, we got some hands-on experience using one of the world's leading \dbms, \postgresql.
We connected to the \postgresql\ \server\ using the \psql\ \client\ software.
We issued commands in the \sql\ language to the \dbms.

What kind of commands did we issue?
Well, we created a new user (or role), we created a \db, we created tables inside the \db, we issued queries to read data back from tables, we used queries to join data from different tables, we created a view and we built queries on top of that view, and we learned how to modify the data in tables.
Finally, we deleted everything again.
This means that we have seen several of the most important \sql\ commands that exist.
Surely, we only have played with them.
We are not even close to really understand their full behavior, special cases, performance issues, nor do we have a clear picture of what happens behind the scenes.

But one thing is clear:
If somebody would come and ask us to create a \db\ for some certain application, we could probably do it.
We could stitch together something that does the trick.
Would it be an efficient \db?
Definitely not.
We did not yet learn anything about how to design nice \pglspl{db}.
We have no experience whatsoever.

Even more so, we also understand how to access a \db\ from outside, from a programming language like \python.
Based on what we learned, we have a rough feeling of what a \dbms\ can and probably cannot do.
This allows us to, in principle, develop ideas for even more complex applications.
The things that the \dbms\ can do should go into the \db.
The things that it cannot, like displaying forms, processing data from some source like sensors or files, or training \pgls{ML} models on the data would go into the \python\ program code.
The two parts of our application would communicate via a library like \psycopg.

Then again, maybe we are a small-scale business where only three or four people have to actually work with the \db.
In such a situation, we probably still want the power of \postgresql.
But making a whole separate program to work with the data may just not be worth the effort.
Plugging a \pgls{GUI} like \libreofficeBase\ in front of the \db\ may then be fully sufficient.
At least entering, viewing, and changing the data will be much much easier compared to using the \psql\ \client.
It also does no longer require any understanding of \sql\ to work with the data.
While we, the \pglspl{dba}, can still use the full features of \postgresql, the secretary in the sales office can now enter new customer data and orders in a way much more natural to them.

For entering data into tables that have complex relationships with other tables, we learned about \emph{forms}.
Forms allow us to deal with the problem of fields that reference rows in other tables via their primary keys.
A customer, for example, is represented only by their \sqlil{id}~value in our \sqlil{demand} table.
Such value is basically meaningless to a salesperson and they would need to look it up in the \sqlil{customer} table to enter the right value.
We can, however, make forms where this looking-up is automated:
The secretary entering the data sees the real customer name but what is stored is the customer~\sqlil{id}.

The second abstract tool we learned about are \emph{reports}.
While it is nice to read and process data in either the table view of \libreofficeBase\ (or \microsoftAccess\ for that matter), this is not the kind of format we would use when printing the data.
A form is also not suitable for this purpose, because forms are designed for entering data.
Reports are the tool exactly designed for this use case:
They allow us to create nicely formatted documents that are automatically filled with data whenever we execute them.

After reading this part of our book, you now have seen several of standard tools and abstractions when working with \pglspl{db} in action.
You do not have any in-depth or theoretical foundation {\dots} but probably a good hunch of what is what and what tool may be suitable for which kind of question.
At this stage, I hope that your curiosity is tickled.
Maybe you even have some problems or application ideas for which you might want to design your own \db.
Maybe to catalog your books or music collection, maybe to construct your ancestry tree, maybe to store your bibliographic references.
Nothing will help you more in learning about \pglspl{db} than doing your own little pet projects.
The second-best thing you can do is to read the rest of this book (or maybe any other book).%
%
\endhsection%
%
