%
\hsection{Join-based Select and Views}%
%
So far, things are going well.
On the positive side, we have learned that we can divide the data of factory into separate aspects and then store it into different tables.
This is nice.
We also learned that we can ensure the integrity of the data inside a single table in various ways.
For example, we can use datatypes that strictly enforce their domains.
\sqlilIdx{DECIMAL}, for example, makes sure that numbers are represented exactly without loss of precision to a fixed number of decimals~\cite{PGDG:PD:NT}.
\sqlilIdx{DATE} ensures that valid dates based on the Gregorian calendar are entered~\cite{PGDG:PD:HU,G1582IG}.
We can also define constraints, ranging from ensuring that all columns are entered~(\sqlilIdx{NOT NULL}) over preventing name clashes~(\sqlilIdx{UNIQUE}) to sanity checks~(via \sqlilIdx{CHECK} \sqlIdx{CONSTRAINT}constraints)~\cite{PGDG:PD:C}.
We also learned that we can even ensure the consistency of the data in our \db\ across different tables via the \sqlilIdx{REFERENCES} constraint~\cite{PGDG:PD:FK}.
So we cannot just have tables, they can have strongly-typed columns and the data integrity can be enforced throughout the complete \db.
This puts \pglspl{rdb} well ahead the spread sheets produced by the likes of \pgls{excel} or \pgls{libreofficeCalc}.

However, on the negative side, we have to admit that using \dbs\ is more complicated.
And we are certainly losing in terms of readability of our data.
Indeed, the meaning of the \sqlil{demand} data shown in \cref{exec:factory:insert_into_table_demand} is not obvious without knowing the contents of the other tables.
Now we will see that we can also \emph{use} these contents of other tables directly in our queries, to produce clear and human-readable output.%
%
\hsection{Joining Tables}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_customer_demand.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_customer_demand}{%
Get the per-customer demands.%
}%
%
We now want to have a list of all of our customers, and for each customer we want to see the \sqlil{id} values of all of the demands (orders) they have issued.
We now step-by-step build the query used in \cref{lst:factory:select_customer_demand}.
So the result of our query should have two columns.
The first column should hold the customer names.
Let's call it \sqlil{customer}.
The second column should hold the \sqlil{id} of the order the customer made.
Let's call this column \sqlil{demand_id}.
Now if a customer issued multiple orders, then they should appear multiple times in this table, once for each demand.
If a customer did not issue any orders, then they should still appear, but only once and with a \sqlilIdx{NULL} value in the \sqlil{demand_id} column.

This means that first, we need all the customer names.
A \sqlil{SELECT name FROM CUSTOMER;} would do this for us.
Now we need to cross-reference the customer \sqlil{id} values in table \sqlil{customer} with the column \sqlil{customer} in table \sqlil{demand}.
We also want to list the customers who did not issue any order.%
%
\begin{sloppypar}%
What we want to do is to apply a so-called \sqlilIdx{LEFT JOIN}\sqlIdx{JOIN!LEFT}, also called \sqlilIdx{LEFT OUTER JOIN}\sqlIdx{JOIN!LEFT OUTER}, of the table \sqlil{customer} to the table \sqlil{demand}~\cite{PGDG:PD:JT}.
The syntax of a left join is basically \sqlil{SELECT <something> FROM table_1 LEFT JOIN table_2 ON (table_1.a = table_2.b)}.
Here \sqlil{<something>} can be any column from \sqlil{table_1} or \sqlil{table_2}.
The columns from \sqlil{table_1} that we want need to be prefixed by \sqlil{table_1.}.
The columns from \sqlil{table_2} that we want need to be prefixed by \sqlil{table_2.}.
The important part of the \sqlilIdx{LEFT JOIN} is the \sqlilIdx{ON} condition.
It can be an arbitrarily complex condition, involving \sqlilIdx{AND} and \sqlil{OR} and whatnot.
However, in the simplest form, it just picks a column from \sqlil{table_1}, here \sqlil{table_1.a} and says that its value must be the same as a column in \sqlil{table_2}, here \sqlil{table_2.b}.%
\end{sloppypar}%
%
We apply this to our situation.
\sqlil{table_1} is obviously \sqlil{customer} and \sqlil{table_2} is \sqlil{demand}.
The thing that we want to select is \sqlil{customer.name} and the corresponding values of \sqlil{demand.id}.
The fields that need to match are \sqlil{customer.id} and \sqlil{demand.customer}.%
%
\begin{sloppypar}%
In \cref{lst:factory:select_customer_demand}, we \sqlil{SELECT customer.name, demand.id} and we do so \sqlil{FROM customer LEFT JOIN demand ON (customer.id = demand.customer)}.
When executed, this query goes through the table~\sqlil{customer}.
For each record, it will take the field~\sqlil{id}, i.e., \sqlil{customer.id}.
It will then search for any row in the table~\sqlil{demand} whose field \sqlil{customer}, i.e., \sqlil{demand.customer} has the same value.
For any such row, it will write a row to the output with the \sqlil{name} of the customer and the \sqlil{id} of the row in \sqlil{demand}.
If and only if no such row exists for a customer, i.e., if the customer did not yet make any purchase, it writes a row to the output with the \sqlil{name} of the customer and \sqlilIdx{NULL} as the \sqlil{demand}~id.
This means that we get the demands associated with each customer name.
We also see which customer did not make any purchase.%
\end{sloppypar}%
%
To clean up the output, we rename \sqlil{customer.name AS customer_name}\sqlIdx{AS} and \sqlil{demand.id AS demand_id}\sqlIdx{AS} to make it clearer which name and id values will be displayed.
We also add an \sqlil{ORDER BY customer_name}\sqlIdx{ORDER BY} to sort the output by customer name.

The result of this query, shown in \cref{exec:factory:select_customer_demand}, has nine rows.
We have eight demands, which are associated with customers Bebba, Bebbo, and Bibbo.
Bobbo did not yet make any purchase, so he appears as a single row with \sqlilIdx{NULL} associated as \sqlil{demand_id}.
The \psql\ \pgls{client} just leaves \sqlil{demand_id} blank in the output.

We now have cross-referenced two tables!
Let us take this a step farther and ask \inQuotes{How many orders did each customer make so far?}
We again answer this question in \cref{lst:factory:select_customer_demand}.
Doing this is rather easy:
First, we replace \sqlil{demand.id AS demand_id} in the query with \sqlil{COUNT(demand.id) as demands}\sqlIdx{COUNT}.
We already learned that \sqlilIdx{COUNT} just counts rows over groups.
But in order to let it count meaningfully, we need to create these groups.
All we have to do for this is to add a \sqlil{GROUP BY customer_name}\sqlIdx{GROUP BY} to the query.
All rows that share a \sqlil{customer_name} go into the same group.
\sqlilIdx{COUNT} now counts the rows in these groups.
The output in \cref{exec:factory:select_customer_demand} shows us that Bebba made two orders, Bebbo~four, and Bibbo also two.
Bobbo so far has zero orders in his name.

With this, we now know how to cross-reference tables.
We have essentially solved the basic annoyance mentioned before:
Yes, our data is distributed over different tables and without knowing what product a product~id refers to and which customer corresponds to which customer~id, it is hard to understand anything.
However, we can just join tables pull all the information together in a query.%
%
\FloatBarrier%
\endhsection%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_view_sale.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_view_sale}{%
Creating a view, i.e., a stored \sql\ query that can be treated like a table, to list the demands in human-readable form.%
}%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_sale.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_sale}{%
Compute the per-customer and per-product sales based on the view \textil{sale}.%
}%
%
\FloatBarrier%
\endhsection%
%
