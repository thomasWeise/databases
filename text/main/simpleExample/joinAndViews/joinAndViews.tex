%
\hsection{Join-based Select and Views}%
%
So far, things are going well.
On the positive side, we have learned that we can divide the data of factory into separate aspects and then store it into different tables.
This is nice.
We also learned that we can ensure the integrity of the data inside a single table in various ways.
For example, we can use datatypes that strictly enforce their domains.
\sqlilIdx{DECIMAL}, for example, makes sure that numbers are represented exactly without loss of precision to a fixed number of decimals~\cite{PGDG:PD:NT}.
\sqlilIdx{DATE} ensures that valid dates based on the Gregorian calendar are entered~\cite{PGDG:PD:HU,G1582IG}.
We can also define constraints, ranging from ensuring that all columns are entered~(\sqlilIdx{NOT NULL}) over preventing name clashes~(\sqlilIdx{UNIQUE}) to sanity checks~(via \sqlilIdx{CHECK} \sqlIdx{CONSTRAINT}constraints)~\cite{PGDG:PD:C}.
We also learned that we can even ensure the consistency of the data in our \db\ across different tables via the \sqlilIdx{REFERENCES} constraint~\cite{PGDG:PD:FK}.
So we cannot just have tables, they can have strongly-typed columns and the data integrity can be enforced throughout the complete \db.
This puts \pglspl{rdb} well ahead the spread sheets produced by the likes of \pgls{excel} or \pgls{libreofficeCalc}.

However, on the negative side, we have to admit that using \dbs\ is more complicated.
And we are certainly losing in terms of readability of our data.
Indeed, the meaning of the \sqlil{demand} data shown in \cref{exec:factory:insert_into_table_demand} is not obvious without knowing the contents of the other tables.
Now we will see that we can also \emph{use} these contents of other tables directly in our queries, to produce clear and human-readable output.%
%
\hsection{Joining Tables}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_customer_demand.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_customer_demand}{%
Get the per-customer demands.%
}%
%
We now want to have a list of all of our customers, and for each customer we want to see the \sqlil{id} values of all of the demands (orders) they have issued.
We now step-by-step build the query used in \cref{lst:factory:select_customer_demand}.
So the result of our query should have two columns.
The first column should hold the customer names.
Let's call it \sqlil{customer}.
The second column should hold the \sqlil{id} of the order the customer made.
Let's call this column \sqlil{demand_id}.
Now if a customer issued multiple orders, then they should appear multiple times in this table, once for each demand.
If a customer did not issue any orders, then they should still appear, but only once and with a \sqlilIdx{NULL} value in the \sqlil{demand_id} column.

This means that first, we need all the customer names.
A \sqlil{SELECT name FROM CUSTOMER;} would do this for us.
Now we need to cross-reference the customer \sqlil{id} values in table \sqlil{customer} with the column \sqlil{customer} in table \sqlil{demand}.
We also want to list the customers who did not issue any order.

What we want to do is to apply a so-called \sqlilIdx{LEFT JOIN}\sqlIdx{JOIN!LEFT}, also called \sqlilIdx{LEFT OUTER JOINT}\sqlIdx{JOIN!LEFT OUTER}, of the table \sqlil{customer} to the table \sqlil{demand}~\cite{PGDG:PD:JT}.
%
\FloatBarrier%
\endhsection%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_view_sale.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_view_sale}{%
Creating a view, i.e., a stored \sql\ query that can be treated like a table, to list the demands in human-readable form.%
}%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_sale.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_sale}{%
Compute the per-customer and per-product sales based on the view \textil{sale}.%
}%
%
\FloatBarrier%
\endhsection%
%
