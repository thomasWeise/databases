%
\hsection{Connecting from Python}%
\label{sec:factoryFromPython}%
%
When we look at what we have achieved so far, we find that it is all pretty nice.
However, there is one general problem we did not really consider yet:
The data is entirely inside the \db.
At first glance, this is where it belongs.
Giving this a second thought, a realization strikes us:
Nobody except us~(the \pglspl{dba} and developers) can really work with this.
Yes, we created the user account \textil{boss} for our boss so that they can log in and work with the data.
But are we really going to explain to them that they will have to use \sql\ for this?
Will a sales manager really insert customer orders into our \db\ by firing up the \sql\ \client\ and then typing \sqlil{INSERT INTO demand (...}?
Probably not.

The data is in the \db, where it belongs.
The \dbms\ can protect it by enforcing our constraints and via its user and rights management.
But only cool people like us can really work with that.
Unsophisticated personnel will gaze at \psql\ puzzled.

We need a way to access and work with the data from the outside.
For this, several possible choices exist.%
%
\begin{enumerate}%
%
\item We can write a our own \client\ program, which offers the user comfortable methods to enter and visualize data.
The program then communicates with the \db.
The user is never bothered with \sql\ and that alike.%
%
\item We can also write the front end in form of a web application, maybe based on the \pgls{flask} \server.
The user then can access our front end via the web browser.
Our program again does the heavy lifting in terms of \sql\ and \db\ interaction.%
%
\item We use a general interface such as \libreofficeBase\ and connect with it to our \db.
In such a tool, we can conveniently design forms for entering the data and reports for visualizing it.
Users can use this front end and still have full access to \sql\ and the entrails of our \db.%
%
\end{enumerate}%
%
Here, we will look at the first and third choice.
The second choice involves maybe a bit too much background knowledge for this stage of \inQuotes{playing with a \db} example.

So let us begin by writing a program that accesses a \postgresql\ \db.
We will use the \python\ programming language~\cite{programmingWithPython}.
I strongly recommend to read our course book~\citetitle{programmingWithPython}~\cite{programmingWithPython} on this subject either before or in parallel.
Things like how to install or work with packages are described there, as well as \pythonil{for}~loops and such and such.

For this part of the example, we need the \python\ programming language and the \psycopg~library installed.
It would probably also be useful to have the \pycharm\ \pgls{ide} ready.
How these pieces of software can be obtained is discussed in \cref{sec:pythonEtAl} and in~\cite{programmingWithPython}.

\python\ is a programming language.
It allows us to write arbitrary programs using datatypes such as \pythonilIdx{int}, \pythonilIdx{float}, and~\pythonilIdx{str}.
We can use control flow statements like~\pythonil{if...then...else}\pythonIdx{if}\pythonIdx{then}\pythonIdx{else}, \pythonilIdx{for}~loops, and \pythonilIdx{while}~loops.
We can define functions using~\pythonilIdx{def}.
It supports \pgls{OOP} and we can create classes using the \pythonilIdx{class}~keyword.
The language does not have any built-in connection with \postgresql.

However, \python\ can use packages, which are libraries that offer additional functionality.
Some well-known packages are \numpy~\cite{HMvdWGVCWTBSKPHvKBHFdRWPGMSRWAGO2020APWN,N2025N,DBvR2024ITN,J2018NPSCADSAWNSAM}, \pandas~\cite{PD2025P,B2012DPWP,L2024PW}, \scikitlearn~\cite{PVGMTGBPWDVPCBPD2011SMLIP,RLM2022MLWPAS}, \scipy~\cite{VGOHRCBPWBvdWBWMMNJKLCPFMVLPCHQHARPvMS2020SFAFSCIP,J2018NPSCADSAWNSAM}, \tensorflow~\cite{ABCCDDDGIIKLMMMSTVWWYZ2016TASFLSML,L2023TDDBTADMLMWT}, or \pytorch~\cite{PGMLBCKLGADKYDRTCSFBC2019PAISHPDLL,RLM2022MLWPAS}.
Such packages are offered in the central \pypi\ repository and can be installed using \pip.
Usually, we will install them into a \pgls{virtualEnvironment} and then use them with our application.
More on this can, again, be found in~\cite{programmingWithPython}.

The important thing is that there is also a \python\ package for connecting with the \postgresql\ \dbms.
This package is called \psycopg~\cite{VDGE2010P} and it implements the standardized \citetitle{PEP249}~\cite{PEP249}.
We briefly outline how to install this package in~\cref{sec:installPsycopg}.
\psycopg\ allows us to construct \sql\ queries inside our \python\ programs, transmit them to the \postgresql\ \server, and to receive the results back in the \python\ program.
This kind of low-level access is perfect for us, since we already learned some basic \sql\ queries.
Thus, the only new thing we need to understand is how to use \psycopg\ to send them to the \dbms\ and how to process the results.
Then, we can use \python\ to interact with our \pglspl{db}.
This gives us the full power of the programming language to process data, which is of course far beyond the capabilities of \sql.%
%
\hsection{Reading Data from the Database}%
%
\gitLoadAndExecPython{factory:connect_and_select}{\databasesCodeRepo}{factory}{connect_and_select.py}{}%
\listingPythonAndOutput{factory:connect_and_select}{A \python\ program connecting to our factory \pgls{db} and executing a \sqlIdx{SELECT{\idxdots}FROM}\sqlil{SELECT} statement.}{}%
%
From here on, let us assume that \psycopg\ is installed and you have opened \cref{lst:factory:connect_and_select} in the \pycharm\ \pgls{ide}.
At its begin, this \python\ program imports two functions from the package \psycopg, which we will use later on, namely \pythonil{connect} and \pythonil{dict_row}.
We will need them to connect to \postgresql\ and to define how we want to receive the results from \sqlil{SELECT}\sqlIdx{SELECT{\idxdots}FROM} statements, respectively.

We now get to the meat of the example.
The first and simplest thing that we can do from \python\ is to read some data from our \db.
For this, we would send a \sqlil{SELECT}\sqlIdx{SELECT{\idxdots}FROM} request to \postgresql.
However, we will not start the \psql\ \client\ and type the command in.
Instead, we will send it from our \python\ program via \psycopg.

To do this, we first need to establish a connection to the \db.
We therefore enter a \pythonilIdx{with} statement, which you also find discussed in our sister course \citetitle{programmingWithPython}~\cite{programmingWithPython}.
The sessions and cursors to the \db\ are implemented as context managers~\cite{PSF:P3D:TPLR:WSCM}, which means that they will automatically be closed at the end of the \pythonilIdx{with} block.
At the beginning of the block, a connection \pythonil{conn} is opened to the \postgresql\ \dbms~\cite{VDGE2022PPDAFP:CC1} by using the \pythonilIdx{connect}~function.
For this purpose, the same connection \pgls{URI} that we already used with \psql\ needs to be specified.
It defines the where the \postgresql\ \server\ can be found, which user and password to use for logging in, and which \db\ we want to work on.
Once the connection is open, the second line in the \pythonilIdx{with} block header opens a cursor~\cite{PEP249,VDGE2022PPDAFP:CC2} in the connection.

Cursors are the objects for sending commands to the \postgresql\ \server\ via a connection and to receive the \server's responses.
They are created with the \pythonilIdx{cursor} method of the connection object.
If a curser is used return results from queries, one may optionally specify a \pythonil{row_factory} parameter.
We here pass in the \pythonilIdx{dict_row} function, which returns each record~(row) resulting from a query as a dictionary of key-value pairs, i.e., a~\pythonilIdx{dict}.
The cursor is stored in a variable named~\pythonil{cur}.
Like the connection object, it will be closed at the end of the \pythonilIdx{with} block.

The cursor object~\pythonil{cur} has a method~\pythonilIdx{execute} which we can use to, well, execute an \sql\ command~\cite{PEP249}.
The first parameter of the function is the \sql\ statement that should be executed.
The optional second parameter can be a sequence of query parameters, but for this first example, we do not need it.
All we want to do is to read all the orders issued by customer Mr.~Bebbo, i.e., by the customer with ID~2.
We thus use the cursor \pythonil{cur} to issue the command \pythonil{"SELECT * FROM demand WHERE customer=2"}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE} via the \pythonilIdx{execute} method.

Once the query is issued, the cursor can be used as \pythonilIdx{Iterator}~\cite{PEP234} in a \pythonilIdx{for}~loop.
We can write \pythonil{for record in cur:}\pythonIdx{in} and this will return the query result row by row.
And since we specified \pythonilIdx{dict_row} as \pythonil{row_factory} when creating the cursor, each row will be a \pythonilIdx{dict}.
This \pythonilIdx{dict} will have the column names keys and the values as, well, values.

After all these \pythonilsIdx{dict} are printed to the \pgls{stdout}, the \pythonil{for}~loop terminates.
Then, the \pythonilIdx{with} block is over, too, which means that first the cursor is closed and then the connection to the \db.
You can find the output of our program in \cref{exec:factory:connect_and_select}.
We remember that Mr.~Bebbo has four orders in his name and we would expect these four orders to be returned.
And they are returned.
As you can see, we have a convenient way to extract data from our \db\ and to use this data in \python.

You can also see that the data has appropriate types:
Data which is integer by nature, such as IDs, is printed as integer numbers.
Date or time data is returned as instances of \pythonilIdx{datetime.date}, i.e., the \python\ datatype to handle such data.%
\FloatBarrier%
\endhsection%
%
\hsection{Inserting Data into the Database}%
%
\gitLoadAndExecPython{factory:connect_and_insert}{\databasesCodeRepo}{factory}{connect_and_insert.py}{}%
\listingPythonAndOutput{factory:connect_and_insert}{A \python\ program connecting to our factory \pgls{db} and then using \sqlilIdx{INSERT INTO} to add some records.}{}%
%
\gitLoadAndExecPython{factory:connect_and_select2}{\databasesCodeRepo}{factory}{connect_and_select.py}{}%
\listingBox{exec:factory:connect_and_select2}{%
The output produced by \cref{lst:factory:connect_and_select} if we execute it a second time after running \cref{lst:factory:connect_and_insert}.%
}{,style=text_style}%
%
We can do more.
Let us now insert some data into the \db\ with program \cref{lst:factory:connect_and_insert}.
When you read this listing, you notice that it begins by importing the type \pythonilIdx{LiteralString} from the standard \pythonilIdx{typing} package.
This type is provided by \python\ for security reasons~\cite{PEP675}:
It helps preventing \pglspl{SQLi}, especially if used together with static type checking tools.
We will not discuss this here any further, but you could read~\cite{PEP675,VDGE2022PPDAFP:ST} to learn more about this issue.
The idea is that several potential attacks on an \sql\ \pgls{server} are made possible if the \sql\ queries are constructed via string concatenation.
A \pythonilIdx{LiteralString} is a string constant written as text in \python.
It is explicitly not the result of any string operation.
Therefore, attacks using string operations as vector are prevented.

Anyway, what we want to do is to insert some new demand records into our \db.
Therefore, we will use the \sqlilIdx{INSERT INTO} statement.
Now the full \sqlilIdx{INSERT INTO} statement is rather long and does not fit on a single line in \cref{lst:factory:connect_and_insert}.
To make using it twice~(as we will) a bit less cumbersome, we store it in a variable \pythonil{statement}.
This variable is annotated with \pgls{typeHint} \pythonilIdx{LiteralString} that we mentioned before.
It represents a string that was typed in as-is, that is not the result of \pgls{strinterpolation}, concatenation, or any other operation.
Either way, we store our statement in this variable.
A bit later we will discuss the meaning and structure of this statement.
For now, just accept it as is.

We now again enter basically he same \pythonilIdx{with} statement as in the previous example.
At the beginning of the block, again a connection~\pythonil{conn} is opened to the \postgresql\ \dbms~\cite{VDGE2022PPDAFP:CC1}.
Then again a cursor~\pythonil{cur}~\cite{VDGE2022PPDAFP:CC2} in the connection is created.
%
\begin{sloppypar}%
We now use again the method~\pythonilIdx{execute} of the cursor.
The first parameter is, as said, the \sql\ statement that should be executed.
The second parameter is a sequence or mapping with parameters of the statement.
This time we need it:
Let us circle back to our statement string constant.
We wrote \pythonil{"INSERT INTO demand (customer, product, amount, ordered) VALUES (\%s,\%s,\%s,\%s)"}.
The first part of this statement is pretty clear:
We will insert a new row into the table~\sqlil{demand} by using the \sqlilIdx{INSERT INTO} command.
We specify the name of the table~(\sqlil{demand}) and the names of the columns that we will set, i.e., \sqlil{customer}, \sqlil{product}, \sqlil{demand}, and sqlil{ordered}.
So far, the command is the same as used in \cref{lst:factory:insert_into_table_demand}.
The difference is in the second part.
After specifying the fields to be set, the original \sql\ command in \cref{lst:factory:insert_into_table_demand} gave the rows to be stored in parentheses with field values separated by commas after the \sqlilIdx{VALUES} keyword.
Here, we instead write \pythonil{"VALUES (\%s,\%s,\%s,\%s)"}.%
\end{sloppypar}%
%
This is because of the aforementioned security concerns.
The \pythonil{"\%s"} are placeholders for parameter values of the query.
These parameter values are supplied as the aforementioned second parameter of the \pythonilIdx{execute} function.
They will be substituted into the query string in a safe fashion that prevents \pglspl{SQLi}.

This means that \pythonil{cur.execute(statement, (3, 4, 5, "2025-03-05" ))} inserts one new row into our table~\sqlil{demand}.
The customer~ID for this row is~3, the product~ID is~4, the product amount is~5, and the ordered date is March~5th, 2025.

After inserting this one row, we use the \pythonilIdx{executemany} method in exactly the same way.
The difference is that this method lets the cursor perform several invocations of a \sql\ command.
The second parameter is a \emph{sequence of} parameter sequences or mappings.
We use this command to insert three rows into the \sqlil{demand} table.
If you read the code in \cref{lst:factory:connect_and_insert}, you find that it is very self-explanatory.
The command looks pretty similar to our normal \sql\ commands, except that we issue it from \python\ code instead of the \psql\ client.

After the command is executed, the cursor and the connection to the \db\ are closed.
The output of the program in \cref{exec:factory:connect_and_insert} looks successful.
We want to check if it really worked by executing \cref{lst:factory:connect_and_select} for a second time.
\Cref{exec:factory:connect_and_select} now lists five orders under customer Bebbo's~ID.
Indeed, we just inserted a new order and it correctly appears.

\gitLoadAndExecSQL{factory:select_from_view_sale_3}{}{factory}{select_from_view_sale_1.sql}{factory}{boss}{superboss123}%
\listingSQLandOutput{factory:select_from_view_sale_3}{%
Repeating the query from \cref{lst:factory:select_from_view_sale_1} after inserting the records using our \python\ program from \cref{lst:factory:connect_and_insert}.%
}{}%
%
Let us now verify that the changes really reached and a are stored in the \db.
For this purpose, we fire up \psql\ and repeat the query from \cref{lst:factory:select_from_view_sale_1}.
The result in \cref{exec:factory:select_from_view_sale_3} the expected increase in sales for customers and products.%
%
\endhsection%
%
\hsection{Summary}%
At first glance, what we did here is not very spectacular.
We have basically written \sql\ commands, like before.
The difference is that we issued them from \python\ instead of the \psql\ \client\ shipping with \postgresql.
This difference, however, is very significant.
With \psql, we can execute \sql\ commands, but that's basically it.
With \python, we can write arbitrarily complex programs.

We could have a user interface with windows and buttons for entering data.
Or we could read data from \pgls{CSV} or \pgls{XML} files and send them to the \dbms.
In the other direction, we can also do lots of sophisticated stuff with data that we pull from the \db.
We could statistically evaluate, or use it to train a \pgls{ML} or \pgls{AI} model that predicts which customer will order which product and when.
We thus now have a new and infinitely powerful tool in our hand to both generate and analyze data.

And \python\ is not the only programming language.
Connectors similar to \psycopg\ exist for \pgls{Java}~\cite{PGDG:PJD} and \pgls{C}~\cite{PGDG:PD:LCL} as well, and probably for many other programming languages, too.
The power to efficiently store and retrieve data and to maintain the data integrity of a \dbms\ can therefore be used from arbitrary programs.%
%
\usefulTool{psycopg}{%
\psycopg~\cite{VDGE2010P} is a library that allows us to connect to the \postgresql\ \dbms\ from \python\ code. %
This way, we can design complex applications in \python\ that interact with a \postgresql\ \db.%
}%
%
\FloatBarrier%
\endhsection%
\endhsection%
%
