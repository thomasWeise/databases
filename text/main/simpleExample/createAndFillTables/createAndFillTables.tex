%
\hsection{Creating Tables and Filling them with Data}%
%
Let us now design the actual \db.
Normally, you would do this in a fancy process where you would draw \pglspl{ERD} and deeply think about the structure of the data, the performance requirements, and so on.
Be that as it may, we are here operating on a learning-by-doing level.
We will just go ahead and build something that looks reasonable, without worrying too much about design principles.

In a \pgls{rdb}, all the data is stored in \emph{tables}.
You are maybe familiar with spreadsheet software such as Microsoft \pgls{excel}.
There, data is organized in tables, too.
In a \pgls{rdb}, however, the columns are strongly typed, i.e., you cannot \inQuotes{write} a text into a field for numbers.
Also, there can be multiple tables, where a record~(row) in one table can be linked to one or multiple records in other tables.
This format allows us to nicely divide into our data according to different semantic aspects.%
%
\hsection{The Table \inQuotes{product}}%
%
Let us begin with storing the the information about the products that our company produces and sells.
We want to store all information that may be relevant to customers and the delivery department.
We will give our first new table the name~\sqlil{product}.%
\bestPractice{tableName}{%
Table names should be singular nous written in lowercase without any prefix~(i.e., no \inQuotes{tbl\_} in front)~\cite{B2025SBPASG}.%
}%
%
\hsection{Creating the Table}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_table_product.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_table_product}{%
Creating the table \textil{product} to store the products we produce and sell.%
}%
%
We can create a new table using the command \sql{CREATE TABLE}\sqlIdx{CREATE!TABLE}, followed by the table name, followed by the attributes that we want to store, as shown in \cref{lst:factory:create_table_product}.

First of all, each product must have a name.
The names could be long or short, but 100~characters per product should suffice.
\sql\ provides the datatype \sqlilIdx{VARCHAR}, which refers to a variable-length string, whose maximum length is specified in parentheses.
We could thus choose \sqlil{VARCHAR(100)} for the column \sqlil{name} for our table~\pythonil{product}.
We thus write~\sqlil{name VARCHAR(100)} for this attribute.
The names must also be unique.
We can never have two different products with the same name.
So we add the keyword~\sqlil{UNIQUE}.
If, later, someone tries to enter a record into our table whose \sqlil{name} attribute value already exists in another record, then this will fail with an error.
We also want to enforce that every single record indeed has a \sqlil{name} attribute set.
There must never be any row in the table without a properly set name.
Therefore, we add the \sqlilIdx{NOT NULL} specification and write \sqlil{name VARCHAR(100)\ UNIQUE NOT NULL}.
Nice, we just defined our very first own attribute.

Additionally, we should store the price at which we sell the product.
The price is clearly a number.
Computers usually provide two fundamental types of numbers on the hardware level, integer numbers and floating point numbers~(a subset of~\realNumbers).
These types also exist in many programming languages.
\python~\cite{programmingWithPython}, for example, offers us the two very basic datatypes \pythonilIdx{int} and \pythonilIdx{float} corresponding to integers and floating point numbers, respectively.
Which one should we use?
Now prices naturally are values with fractions, something like \$99.99 or 17.75元, so at first glance, the \sql\ equivalent of \python's \pythonilIdx{float} seems a reasonable choice here.
However, it is actually not, because in \cite{programmingWithPython}, we write:%
%
\bestPractice{floatImprecise}{%
Always assume that any \pythonilIdx{float} value is imprecise. %
Never expect it to be exact~\cite{PTVF2007EAAS,BHK2006NS}.%
}%
%
\begin{sloppypar}%
Indeed, using double precision IEEE~Standard 754 floating point numbers~\cite{IEEE2019ISFFPA,H1997IS7FPN}, the expression~\pythonil{0.1 + 0.1 + 0.1 - 0.3} may yield~\pythonil{5.551115123125783e-17} as result.
Thus, if we stored~0.3元 as a price in our \db\ using floating point numbers and a customer transferred three times~一毛钱, then the bank may encounter problems if we want to transfer $5.551115123125783*10^{-17}$元 back as change\dots
\end{sloppypar}%
%
\bestPractice{moneyNotFloat}{%
Never represent monetary data with floating point numbers~\cite{S2010WNUDOFTRC,W2020HSISCVISS}.%
}%
%
We could use integer numbers representing the number of cents instead, but then we would always need to use some arithmetics to properly display prices, which also creates a potential for errors~\cite{W2020HSISCVISS}.
Actually neither integers nor floating point numbers are the right choice!
Instead, we will use the datatype~\sqlilIdx{DECIMAL}, which can represent a fractional number with a pre-defined number of digits exactly.
Writing \sqlil{price DECIMAL(10, 2)} allows us to store values with 10~digits, 2~of these 10~digits are after the comma~\cite{PGDG:PD:NT}.
This means that we can store values between -99\decSep999\decSep999.99 and~99\decSep999\decSep999.99.
This should be enough for prices of products in our shoe and handbag factory.
Of course, each product must have a price, so we add again the \sqlilIdx{NOT NULL} keyword.%
%
\bestPractice{moneyDecimal}{%
Store monetary using the \sqlilIdx{DECIMAL} datatype~\cite{C2024SCVDTCBP,W2020HSISCVISS}.%
}%
%
We will sell each product in a box.
Therefore, we also want to store the width, height, and depth as well as the weight of the packaged box.
For the height, width, and depth, we will use millimeter as unit and for the weight grams.
We can store values using the datatype \sqlilIdx{INT}, which is a shorthand for \sqlilIdx{INTEGER} and can hold values from -2\decSep147\decSep483\decSep648 to +2\decSep147\decSep483\decSep647.
Each product must have values specified for all four dimensions, so we again mark them as~\sqlilIdx{NOT NULL}.

Tables in a \db\ do not exist in an isolated manner.
Instead, they will reference each other.
For example, later we will create a table where we store which customer bought which product.
For this, we will need at least three tables:
A table of customers (which we do not yet have), the table of products (that we are creating right now), and a table for the customer orders.
Each record in that last table will reference one row in the customers table and one row in the products table.

For allowing the latter, we need a unique way to identify each row in our table.
Now our table already has a column with unique values, namely~\sqlil{name}.
However, these are of type \sqlilIdx{VARCHAR}, i.e., they are potentially long strings.
This would mean that each record in the orders table would also need to store the long \sqlil{name} string.
This would probably be inefficient~\cite{M2014VPKM}.
Also, maybe later we have many other records referencing a certain product by its name {\dots} but the marketing department chooses to change the name of the product.
This could wreak havoc to our \db.
It is better to use an automatically generated unique value as key that will never change even if we change the name of a product~\cite{B2025SBPASG}.%
%
%
\begin{sloppypar}%
We therefore add another column that we are going to call~\sqlil{id}, which should hold a unique integer value.
We define it as \sqlil{id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY}.
The \sqlil{GENERATED BY DEFAULT AS IDENTITY}\sqlIdx{GENERATED{\idxdots}AS IDENTITY}~\cite{PGDG:PD:IC} means that we do not need to specify values for this column when storing data.
The system will automatically choose the next integer value that was not yet used.
Here, \sqlIdx{GENERATED{\idxdots}AS IDENTITY!BY DEFAULT}\sqlil{BY DEFAULT} tell the system that we \emph{can} specify values for \sqlil{id} if we want to, which then take precedence over the generated values.
This could be useful if we want to keep the values of \sqlil{id} if backup parts of the table elsewhere and then want to reinsert them.
Alternatively, we could also have written \sqlIdx{GENERATED{\idxdots}AS IDENTITY!ALWAYS}\sqlil{ALWAYS}, in which case the \sqlil{id} values will always be generated automatically.
We will use this column as the so called \sqlilIdx{PRIMARY KEY}, i.e., as the value that should be used by other tables to reference rows in our \sqlil{product} table.
The annotation with \sqlilIdx{PRIMARY KEY} also automatically enforces that only unique values can be stored.%
\end{sloppypar}%
%
\bestPractice{surrogatePrimaryKey}{%
Prefer using surrogate primary keys based on automatically incremented integers~\cite{B2025SBPASG}.%
}%
%
\bestPractice{primaryKeyId}{%
Whenever using an automatically incremented integer as primary key for a table, name it~\sqlil{id}. %
While there is some controversy about this topic~\cite{L2011WINATPKCICBPC}, anybody accessing your \db\ will immediately understand the meaning of the \sqlil{id}~columns and this practice is used in many sources~\cite{B2025SBPASG,PGDG:PD}.%
}%
%
This completes the \sql\ command for creating our very first table.
We can now fire up \psql\ again.
Notice that, since the \db\ belongs to the user \sqlil{boss}, we now log in as \sqlil{boss} using their password \sqlil{superboss123}.
We also want to work on the \db\ \sqlil{database}.
The \postgresql\ connection \pgls{URI} for the \db\ \pgls{server} running on our current computer (identified by \localhost) and therefore is \textil{postgres://boss:superboss123@localhost/factory}.
We use it in \cref{exec:factory:create_table_product} to submit the table creation command given in \cref{lst:factory:create_table_product}.%
%
\begin{sloppypar}%
Additionally, we also want to check whether the commands worked correctly.
Before creating the new table, we thus print the list of tables owned by user \sqlil{boss}.
All of them are stored in table \sqlilIdx{pg\_catalog.pg\_tables} in the \postgresql\ \pgls{server}.
We only print the table names, which are in column~\sqlilIdx{tablename}.
We only want to see those owned by \sqlil{boss}, so we add the statement \sqlil{WHERE tableowner = 'boss'}.
The name of the user owning each table is stored in column \sqlilIdx{tableowner}, and only if it equals \sqlil{boss}, we print the table name.
This results in the query \sqlil{SELECT tablename FROM pg_catalog.pg_tables WHERE tableowner = 'boss';}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}.
As you can see, before executing the \sqlil{CREATE TABLE}\sqlIdx{CREATE!TABLE} command, this query returns nothing.
Afterwards, one new table exists, namel~\sqlil{product}.%
\end{sloppypar}%
\FloatBarrier%
\endhsection%
%
\hsection{Inserting some Data}\afterpage{\clearpage}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_product.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_product}{%
Storing some products in the table~\sqlil{product}.%
}%
%
Now the table \sqlil{product} exists, but it is empty.
Let us fill it with data.
Our factory has two products:~\inQuotes{Shoe} and~\inQuotes{Purse.}
The shoes come in sizes~36 to~43.
Their prices start at 150.99元 for size~36 and increase by 2元 per size.
They all fit into the same box.
The smallest shoes weight 1300g and the weight increases by 25g per size.
Purses come in sizes \emph{small}, \emph{medium}, and \emph{large}, at prices of 100元, 120元, and 150元, respectively.
They weight 500g, 750g, and 1500g, respectively.
The smallest purse fits into a shoebox, but the bigger ones require bigger boxes.

We store this data into the table \sqlil{product} by an \sqlilIdx{INSERT INTO} statement.
Here, we first need to provide the table name (\sqlil{product}) and the attributes that we want to store in parentheses, i.e., \inQuotes{\sqlil{(...)}}.
We will store values for the fields \sqlil{name}, \sqlil{price}, \sqlil{weight}, \sqlil{width}, \sqlil{height}, and~\sqlil{depth}.
We do not need to store values for~\sqlil{id}, because they will be automatically generated for us.
After saying what we want to store, we specify the \sqlilIdx{VALUES} to store.
Each row is written in parentheses, values and rows are separated by commas.
The complete command for storing all the data is shown in \cref{lst:factory:insert_into_table_product}.

There, we first print all the data currently in the table by typing \sqlil{SELECT * FROM product;}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}\sqlIdx{*}.
This prints nothing, because the table is empty.
Then we insert the eleven products via one single \sqlilIdx{INSERT INTO} command.
Afterwards, we try \sqlil{SELECT * FROM product;}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}\sqlIdx{*} again -- and now it prints 11~rows.

Before we continue, let us briefly check what the \sqlilIdx{UNIQUE} constraint that we have defined on column~\sqlil{name} does.
Basically, it says that there cannot be two records in our table with the same value of~\sqlil{name}.
Therefore, if we would try to insert another product with name \sqlil{'Shoe, Size 36'} into the table, this should fail.
Because we already have a row with this value.
We test this in \cref{lst:factory:insert_into_table_product_error}.
Indeed, \cref{exec:factory:insert_into_table_product_error} shows that this fails with an error and the data remains unchanged.%
%
\endhsection%
%
\hsection{Selecting Data}%
%
Now we have stored data in the table \sqlil{product}.
But how can we get it out again?
Well, you already learned a good part of how to do that:~\sqlil{SELECT * FROM product;}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}\sqlIdx{*}.
This query lists basically all of the data in the table.
You have seen it its output at the bottom of \cref{exec:factory:insert_into_table_product}.

Yet, most often, we do not want to retrieve \emph{all} of the data in a table.
Usually, we only want some part of the data.
Maybe we only want to see the rows (records) that match certain criteria.
Maybe we only want to see a subset of the columns.
Maybe we even want to compute some statistics.
How can we do that?
A large part of the answer is \inQuotes{With the \sqlil{SELECT}\sqlIdx{SELECT{\idxdots}FROM} statement.}

This is a seduce-to-use example, something to play around with.
So we will play around with the data for a bit in \cref{lst:factory:select_from_table_product}.

First, let's say that we want a list of the names and prices of all types of purses that we sell.
Let us amend the original query \sqlil{SELECT * FROM product;} for this purpose.
The \sqlilIdx{*} here means that all columns should be printed.
Naturally, we would replace it with the columns that we want, namely, \sqlil{name} and \sqlil{price}.
We write \sqlil{SELECT name, price FROM product;}.
This gives us the names and prices of \emph{all} products in our table.
We need to narrow this down to purses.
We can add a \sqlilIdx{WHERE} clause at the end of the query where we can supply a condition.
Only the records that match the condition will be shown.
What condition can we use?
\sql\ offers us some \emph{pattern matching methods}~\cite{PGDG:PD:PM}.
The pattern \sqlil{LIKE '\%Purse\%'}\sqlIdx{LIKE}\sqlIdx{\%} will match any string that contains the text~\inQuotes{Purse}.
The condition \sqlil{name LIKE '\%Purse\%'} therefore requires that the product name contains the text~\inQuotes{Purse}.
Our first real query thus becomes \sqlil{SELECT name, price FROM product WHERE name LIKE '\%Purse\%';}.
As you can see in \cref{exec:factory:select_from_table_product}, it will return three rows of purse-related data.%
%
\begin{sloppypar}%
Assume now that you are a lady who wants to purchase some fashion accessory to accentuate your beauty.
Naturally, you would want to buy the product that gives you the best deal in terms of product weight per monetary unit, i.e, g~per~元.
Therefore, for each product, we would like to divide the weight by the price and give this new value the name \sqlil{g_per_yuan}.
Luckily, \sql\ supports mathematical expressions~\cite{PGDG:PD:MFAO}, so it is possible to write \sqlil{weight / price}.
The query \sqlil{SELECT name, weight / price AS g_per_yuan from product;} would return the product name and the weight-cost ration.
\sqlil{weight / price AS g_per_yuan}\sqlIdx{AS} means that the ratio of weight and price will be computed and given the name \sqlil{g_per_yuan}.%
\end{sloppypar}%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_product_error.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_product_error}{%
Showing how the \sqlilIdx{UNIQUE} constraint on column \sqlil{name} prevents us from inserting a product with the same name as an already existing one into table \sqlil{product}.%
}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_from_table_product.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_from_table_product}{%
Selecting information from the table \textil{product}.}%
%
Suppose that our table \sqlil{product} contains hundreds of entries.
It would be very hard to spot good deals in that heap of data.
Luckily, \sql\ also allows to sort data.
We would like to see our list sorted based on \sqlil{g_per_yuan} from large to small values.
This way, the best deals will come first.
We can do that by simply adding \sqlil{ORDER BY g_per_yuan DESC}\sqlIdx{ORDER BY}\sqlIdx{DESC}.
\sqlilIdx{ORDER BY} sorts the rows of the query result by the fields listed afterwards.
By default, it will sort in an ascending order, i.e., with small values coming first.
We want a descending order, so we also write~\sqlilIdx{DESC}.

Finally, we may realize that there are still way to many entries returned.
We only care about the best five or so deals, the rest does not matter anyway.
All we have to do to limit the number of rows returned to five is to, well, add~\sqlil{LIMIT 5}\sqlIdx{LIMIT} to our query.
With this, the query is completed.
It is the second one in \cref{lst:factory:select_from_table_product}.

Its result in \cref{exec:factory:select_from_table_product} shows us that the large purse is definitely the best deal here.
For every single~元, we can get 10g of product!
Indeed, the purse weights 1.5kg and costs 150元, so the result is correct.
The second-best deal would be the largest shoe in stock.
At size~43, we can 8.94g of product per~元.

What else can we find out about the data in this table?
What if we wanted to know whether shoes or purses costed more on average?
First, let's figure out how to compute arithmetic means in \sql.
It is rather easy.
We could write \sqlil{SELECT AVG(price) FROM product;}\sqlIdx{AVG} to get the arithmetic mean over all values in the column \sqlil{price} in the table \sqlil{product}~\cite{PGDG:PD:AF}.
This query would return a single row with a single value named \sqlil{avg}.
That value would be \sqlil{148.5381818181818182} if you want to try it by yourself.

Let's give the value a better name.
Let's try \sqlil{SELECT AVG(price) AS mean_price FROM product;}\sqlIdx{AVG}
The result would still be pretty much the same, but now the returned column is named~\sqlil{mean_price} (and there still only a single row).%
%
\begin{sloppypar}%
As the next step, let's compute the average price for purses.
We can reuse the condition \sqlil{WHERE name LIKE '\%Purse\%'} from before and write \sqlil{SELECT AVG(price) AS mean_price FROM product WHERE name LIKE '\%Purse\%';}
This returns a single column named \sqlil{mean_price} and a single row.
The value in that row is now \sqlil{123.3333333333333333}, which indeed is the arithmetic mean of 100, 120, and~150.
To make clear that this is the purse price, we can simply add an artificial column named~\sqlil{kind} with value~\sqlil{'Purse'}.
\sqlil{SELECT 'Purse' AS kind, AVG(price) AS mean_price FROM product WHERE name LIKE '\%Purse\%';}.
Now we got two columns, \sqlil{kind} and \sqlil{mean_price}, and one row with the values \textil{Purse} and \sqlil{123.3333333333333333}.%
\end{sloppypar}%
%
\begin{sloppypar}%
We can, of course, do the same for shoes.
All we have to do is to replace \sqlil{'\%Purse\%'} with \sqlil{'\%Shoe\%'} and change the \sqlil{kind} column accordingly.
\sqlil{SELECT 'Shoe' AS kind, AVG(price) AS mean_price FROM product WHERE name LIKE '\%Shoe\%';} returns also a single row with values \textil{Shoe} and \textil{157.9900000000000000}.
Indeed, the average price of all of our shoes is 157.99元.%
\end{sloppypar}%
%
So we have two queries that each return two values with the same names.
At this point, we already know that purses are cheaper than shoes in average.
But having two queries is somehow unsatisfying.
We want to package both results together, so that we get the two rows as the result of a single \sql\ command.

Nothing easier than that!
We just have to remove the trailing~\sqlil{;} from the first query and write a \sqlilIdx{UNION ALL} directly in front of the second query~\cite{PGDG:PD:CQUIE}!
The \sqlilIdx{UNION ALL} statement effectively appends the results of the second query to the results of the first query.
The combined statement is shown at the bottom of \cref{lst:factory:select_from_table_product} and its result is given in \cref{exec:factory:select_from_table_product}.

At this point, please notice the beauty of queries:
We can continue to add data to our table.
We can change values or delete values.
But the queries will still work all the same and always give us the up-to-date results.%
\endhsection%
\FloatBarrier%
\endhsection%
%
\hsection{The Table \inQuotes{customer}}%%
Next, we design a table for managing customer data.%
%
\hsection{Creating the Table}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_table_customer.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_table_customer}{%
Creating the table \textil{customer} to store the information about our factory's customers.%
}%
%
\begin{sloppypar}%
We create the table \sqlil{customer} using the \sqlilIdx{CREATE TABLE} command in \cref{lst:factory:create_table_customer}.
The first attribute again should be the primary key~\sqlil{id}, which we again define as \sqlil{INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY}.%
\end{sloppypar}%
%
\endhsection%
%
\hsection{Inserting some Data}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_customer.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_customer}{%
Storing some customer records in the table \textil{customer}.%
}%
\endhsection%
%
\endhsection%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_table_demand.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_table_demand}{%
Creating the table \textil{demand} to store the orders of our customers.%
}%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_demand.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_demand}{%
Storing some order records in the table \textil{demand}.%
}%
%
\FloatBarrier%
\endhsection%
%
