%
\hsection{Creating Tables and Filling them with Data}%
\label{sec:factoryCreatingTableAndInsertingData}%
%
Let us now design the actual \db.
Normally, you would do this in a fancy process where you would draw \pglspl{ERD} and deeply think about the structure of the data, the performance requirements, and so on.
Be that as it may, we are here operating on a learning-by-doing level.
We will just go ahead and build something that looks reasonable, without worrying too much about design principles.

In a \pgls{rdb}, all the data is stored in \emph{tables}.
You are maybe familiar with spreadsheet software such as \microsoftExcel.
There, data is organized in tables, too.
In a \pgls{rdb}, however, the columns are strongly typed, i.e., you cannot \inQuotes{write} a text into a field for numbers.
Also, there can be multiple tables, where a record~(row) in one table can be linked to one or multiple records in other tables.
This format allows us to nicely divide into our data according to different semantic aspects.%
%
\hsection{The Table \inQuotes{product}}%
%
Let us begin with storing the the information about the products that our company produces and sells.
We want to store all information that may be relevant to customers and the delivery department.
We will give our first new table the name~\sqlil{product}.%
%
\bestPractice{tableName}{%
Table names should be singular nous written in lowercase without any prefix~(i.e., no \inQuotes{tbl\_} in front)~\cite{B2025DS:SBPASG}.%
}%
%
\hsection{Creating the Table}%
\label{sec:factory:table:product}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_table_product.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_table_product}{%
Creating the table \textil{product} to store the products we produce and sell.%
}%
%
We can create a new table using the command \sql{CREATE TABLE}\sqlIdx{CREATE!TABLE}, followed by the table name, followed by the attributes that we want to store, as shown in \cref{lst:factory:create_table_product}.

First of all, each product must have a name.
The names could be long or short, but 100~characters per product should suffice.
\sql\ provides the datatype \sqlilIdx{VARCHAR}, which refers to a variable-length string, whose maximum length is specified in parentheses~\cite{PGDG:PD:CT}.
We could thus choose \sqlil{VARCHAR(100)}\sqlIdx{VARCHAR} for the column \sqlil{name} for our table~\pythonil{product}.
We thus write~\sqlil{name VARCHAR(100)}\sqlIdx{VARCHAR} when defining this column.
The names must also be unique.
We can never have two different products with the same name.
So we add the keyword~\sqlil{UNIQUE}~\cite{PGDG:PD:C}.
If, later, someone tries to enter a record into our table whose \sqlil{name} value already exists in another record, then this will fail with an error.
We also want to enforce that every single record indeed has a \sqlil{name} value set.
There must never be any row in the table without a properly set name.
Therefore, we add the \sqlilIdx{NOT NULL} specification and write \sqlil{name VARCHAR(100)\ UNIQUE NOT NULL}\sqlIdx{VARCHAR}\sqlIdx{NOT NULL}\sqlIdx{UNIQUE}~\cite{PGDG:PD:C}.
Nice, we just defined our very first own column.

Additionally, we should store the price at which we sell the product.
The price is clearly a number.
Computers usually provide two fundamental types of numbers on the hardware level, integer numbers and floating point numbers~(a subset of~\realNumbers).
These types also exist in many programming languages.
\python~\cite{programmingWithPython}, for example, offers us the two very basic datatypes \pythonilIdx{int} and \pythonilIdx{float} corresponding to integers and floating point numbers, respectively.
Which one should we use?
Now prices naturally are values with fractions, something like \$99.99 or 17.75元, so at first glance, the \sql\ equivalent of \python's \pythonilIdx{float} seems a reasonable choice here.
However, it is actually not, because in \cite{programmingWithPython}, we write:%
%
\bestPractice{floatImprecise}{%
Always assume that any \pythonilIdx{float} value is imprecise. %
Never expect it to be exact~\cite{PTVF2007EAAS,BHK2006NS,programmingWithPython}.%
}%
%
\begin{sloppypar}%
Indeed, using double precision IEEE~Standard 754 floating point numbers~\cite{IEEE2019ISFFPA,H1997IS7FPN}, the expression~\pythonil{0.1 + 0.1 + 0.1 - 0.3} may yield~\pythonil{5.551115123125783e-17} as result.
Thus, if we stored~0.3元 as a price in our \db\ using floating point numbers and a customer transferred three times~一毛钱, then the bank may encounter problems if we want to transfer $5.551115123125783*10^{-17}$元 back as change\dots
\end{sloppypar}%
%
\bestPractice{moneyNotFloat}{%
Never represent monetary data with floating point numbers~\cite{S2010WNUDOFTRC,W2020HSISCVISS}.%
}%
%
We could use integer numbers representing the number of cents instead, but then we would always need to use some arithmetics to properly display prices, which also creates a potential for errors~\cite{W2020HSISCVISS}.
Actually neither integers nor floating point numbers are the right choice!
Instead, we will use the datatype~\sqlilIdx{DECIMAL}, which can represent a fractional number with a pre-defined number of digits exactly.
Writing \sqlil{price DECIMAL(10, 2)} allows us to store values with 10~digits, 2~of these 10~digits are after the comma~\cite{PGDG:PD:NT}.
This means that we can store values between -99\decSep999\decSep999.99 and~99\decSep999\decSep999.99.
This should be enough for prices of products in our shoe and handbag factory.
Of course, each product must have a price, so we add again the \sqlilIdx{NOT NULL} keyword.%
%
\bestPractice{moneyDecimal}{%
Store monetary data using the \sqlilIdx{DECIMAL} datatype~\cite{C2024SCVDTCBP,W2020HSISCVISS}.%
}%
%
We will sell each product in a box.
Therefore, we also want to store the width, height, and depth as well as the weight of the packaged box.
For the height, width, and depth, we will use millimeter as unit and for the weight we use grams.
We can store values using the datatype \sqlilIdx{INT}, which is a shorthand for \sqlilIdx{INTEGER} and can hold values from -2\decSep147\decSep483\decSep648 to +2\decSep147\decSep483\decSep647.
Each product must have values specified for all four dimensions, so we again mark them as~\sqlilIdx{NOT NULL}.

Tables in a \db\ do not exist in an isolated manner.
Instead, they will reference each other.
For example, later we will create a table where we store which customer bought which product.
For this, we will need at least three tables:
A table of customers~(which we do not yet have), the table of products (that we are creating right now), and a table for the customer orders.
Each record in that last table will reference one row in the customers table and one row in the products table.

For allowing the latter, we need a unique way to identify each row in our table.
Now our table already has a column with unique values, namely~\sqlil{name}.
However, these are of type \sqlilIdx{VARCHAR}, i.e., they are potentially long strings.
This would mean that each record in the orders table would also need to store the long \sqlil{name} string.
This would probably be inefficient~\cite{M2014VPKM}.
Also, maybe later we have many other records referencing a certain product by its name {\dots} but the marketing department chooses to change the name of the product.
This could wreak havoc to our \db.
It is better to use an automatically generated unique value as key that will never change even if we change the name of a product~\cite{B2025DS:SBPASG}.%
%
\begin{sloppypar}%
We therefore add another column that we are going to call~\sqlil{id}, which should hold a unique integer value.
We define it as \sqlil{id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY}\sqlIdx{INT}\sqlIdx{GENERATED}\sqlIdx{BY DEFAULT}\sqlIdx{PRIMARY KEY}\sqlIdx{IDENTITY}.
The \sqlil{GENERATED BY DEFAULT AS IDENTITY}\sqlIdx{GENERATED{\idxdots}AS IDENTITY}~\cite{PGDG:PD:IC} means that we do not need to specify values for this column when storing data.
The system will automatically choose the next integer value that was not yet used.
Here, \sqlIdx{GENERATED{\idxdots}AS IDENTITY!BY DEFAULT}\sqlil{BY DEFAULT} tell the system that we \emph{can} specify values for \sqlil{id} if we want to, which then take precedence over the generated values.
This could be useful if we want to keep the values of \sqlil{id} if backup parts of the table elsewhere and then want to reinsert them.
Alternatively, we could also have written \sqlIdx{GENERATED{\idxdots}AS IDENTITY!ALWAYS}\sqlil{ALWAYS}, in which case the \sqlil{id} values will always be generated automatically.
We will use this column as the so called \sqlilIdx{PRIMARY KEY}, i.e., as the value that should be used by other tables to reference rows in our \sqlil{product} table.
The annotation with \sqlilIdx{PRIMARY KEY} also automatically enforces that only unique values can be stored.%
\end{sloppypar}%
%
\bestPractice{surrogatePrimaryKey}{%
Prefer using surrogate primary keys based on automatically incremented integers~\cite{B2025DS:SBPASG}. %
See also \cref{def:surrogateKey}.%
}%
%
\bestPractice{primaryKeyId}{%
Whenever using an automatically incremented integer as primary key for a table, name it~\sqlil{id}. %
While there is some controversy about this topic~\cite{L2011WINATPKCICBPC}, anybody accessing your \db\ will immediately understand the meaning of the \sqlil{id}~columns and this practice is used in many sources~\cite{B2025DS:SBPASG,PGDG:PD}.%
}%
%
This completes the \sql\ command for creating our very first table.
We can now fire up \psql\ again.
Notice that, since the \db\ belongs to the user \sqlil{boss}, we now log in as \sqlil{boss} using their password \sqlil{superboss123}.
We also want to work on the \db\ \sqlil{database}.
The \postgresql\ connection \pgls{URI} for the \db\ \pgls{server} running on our current computer~(identified by \localhost) and therefore is \textil{postgres://boss:superboss123@localhost/factory}.
We use it in \cref{exec:factory:create_table_product} to submit the table creation command given in \cref{lst:factory:create_table_product}.%
%
\begin{sloppypar}%
Additionally, we also want to check whether the commands worked correctly.
Before creating the new table, we thus print the list of tables owned by user \sqlil{boss}.
All of them are stored in table \sqlilIdx{pg\_catalog.pg\_tables} in the \postgresql\ \pgls{server}.
We only print the table names, which are in column~\sqlilIdx{tablename}.
We only want to see those owned by \sqlil{boss}, so we add the statement \sqlil{WHERE tableowner = 'boss'}.
The name of the user owning each table is stored in column \sqlilIdx{tableowner}, and only if it equals \sqlil{boss}, we print the table name.
This results in the query \sqlil{SELECT tablename FROM pg_catalog.pg_tables WHERE tableowner = 'boss';}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}.
As you can see, before executing the \sqlil{CREATE TABLE}\sqlIdx{CREATE!TABLE} command, this query returns nothing.
Afterwards, one new table exists, namel~\sqlil{product}.%
\end{sloppypar}%
\FloatBarrier%
\endhsection%
%
\hsection{Inserting some Data}\afterpage{\clearpage}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_product.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_product}{%
Storing some products in the table~\sqlil{product}.%
}%
%
Now the table \sqlil{product} exists, but it is empty.
Let us fill it with data.
Our factory has two products:~\inQuotes{Shoe} and~\inQuotes{Purse.}
The shoes come in sizes~36 to~43.
Their prices start at 150.99元 for size~36 and increase by 2元 per size.
They all fit into the same box.
The smallest shoes weight 1300g and the weight increases by 25g per size.
Purses come in sizes \emph{small}, \emph{medium}, and \emph{large}, at prices of 100元, 120元, and 150元, respectively.
They weight 500g, 750g, and 1500g, respectively.
The smallest purse fits into a shoebox, but the bigger ones require bigger boxes.

We store this data into the table \sqlil{product} by an \sqlilIdx{INSERT INTO} statement.
Here, we first need to provide the table name~(\sqlil{product}) and the attributes that we want to store in parentheses, i.e., \inQuotes{\sqlil{(...)}}.
We will store values for the fields \sqlil{name}, \sqlil{price}, \sqlil{weight}, \sqlil{width}, \sqlil{height}, and~\sqlil{depth}.
We do not need to store values for~\sqlil{id}, because they will be automatically generated for us.
After saying what we want to store, we specify the \sqlilIdx{VALUES} to store.
Each row is written in parentheses, values and rows are separated by commas.
The complete command for storing all the data is shown in \cref{lst:factory:insert_into_table_product}.

There, we first print all the data currently in the table by typing \sqlil{SELECT * FROM product;}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}\sqlIdx{*}.
This prints nothing, because the table is empty.
Then we insert the eleven products via one single \sqlilIdx{INSERT INTO} command.
Afterwards, we try \sqlil{SELECT * FROM product;}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}\sqlIdx{*} again -- and now it prints 11~rows.

Before we continue, let us briefly check what the \sqlilIdx{UNIQUE} constraint that we have defined on column~\sqlil{name} does.
Basically, it says that there cannot be two records in our table with the same value of~\sqlil{name}.
Therefore, if we would try to insert another product with name \sqlil{'Shoe, Size 36'} into the table, this should fail.
Because we already have a row with this value.
We test this in \cref{lst:factory:insert_into_table_product_error}.
Indeed, \cref{exec:factory:insert_into_table_product_error} shows that this fails with an error and the data remains unchanged.%
%
\endhsection%
%
\hsection{Selecting Data}%
%
Now we have stored data in the table \sqlil{product}.
But how can we get it out again?
Well, you already learned a good part of how to do that:~\sqlil{SELECT * FROM product;}\sqlIdx{SELECT{\idxdots}FROM}\sqlIdx{WHERE}\sqlIdx{*}.
This query lists basically all of the data in the table.
You have seen it its output at the bottom of \cref{exec:factory:insert_into_table_product}.

Yet, most often, we do not want to retrieve \emph{all} of the data in a table.
Usually, we only want some part of the data.
Maybe we only want to see the rows~(records) that match certain criteria.
Maybe we only want to see a subset of the columns.
Maybe we even want to compute some statistics.
How can we do that?
A large part of the answer is \inQuotes{With the \sqlil{SELECT}\sqlIdx{SELECT{\idxdots}FROM} statement.}

This is a seduce-to-use example, something to play around with.
So we will play around with the data for a bit in \cref{lst:factory:select_from_table_product}.

First, let's say that we want a list of the names and prices of all types of purses that we sell.
Let us amend the original query \sqlil{SELECT * FROM product;} for this purpose.
The \sqlilIdx{*} here means that all columns should be printed.
Naturally, we would replace it with the columns that we want, namely, \sqlil{name} and \sqlil{price}.
We write \sqlil{SELECT name, price FROM product;}.
This gives us the names and prices of \emph{all} products in our table.
We need to narrow this down to purses.
We can add a \sqlilIdx{WHERE} clause at the end of the query where we can supply a condition.
Only the records that match the condition will be shown.
What condition can we use?
\sql\ offers us some \emph{pattern matching methods}~\cite{PGDG:PD:PM}.
The pattern \sqlil{LIKE '\%Purse\%'}\sqlIdx{LIKE}\sqlIdx{\%} will match any string that contains the text~\inQuotes{Purse}.
The condition \sqlil{name LIKE '\%Purse\%'} therefore requires that the product name contains the text~\inQuotes{Purse}.
Our first real query thus becomes \sqlil{SELECT name, price FROM product WHERE name LIKE '\%Purse\%';}.
As you can see in \cref{exec:factory:select_from_table_product}, it will return three rows of purse-related data.%
%
\begin{sloppypar}%
Assume now that you are a lady who wants to purchase some fashion accessory to accentuate your beauty.
Naturally, you would want to buy the product that gives you the best deal in terms of product weight per monetary unit, i.e, g~per~元.
Therefore, for each product, we would like to divide the weight by the price and give this new value the name \sqlil{g_per_yuan}.
Luckily, \sql\ supports mathematical expressions~\cite{PGDG:PD:MFAO}, so it is possible to write \sqlil{weight / price}.
The query \sqlil{SELECT name, weight / price AS g_per_yuan from product;} would return the product name and the weight-cost ration.
\sqlil{weight / price AS g_per_yuan}\sqlIdx{AS} means that the ratio of weight and price will be computed and given the name \sqlil{g_per_yuan}.%
\end{sloppypar}%
%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_product_error.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_product_error}{%
Showing how the \sqlilIdx{UNIQUE} constraint on column \sqlil{name} prevents us from inserting a product with the same name as an already existing one into table \sqlil{product}.%
}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_from_table_product.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_from_table_product}{%
Selecting information from the table \textil{product}.}%
%
Suppose that our table \sqlil{product} contains hundreds of entries.
It would be very hard to spot good deals in that heap of data.
Luckily, \sql\ also allows to sort data.
We would like to see our list sorted based on \sqlil{g_per_yuan} from large to small values.
This way, the best deals will come first.
We can do that by simply adding \sqlil{ORDER BY g_per_yuan DESC}\sqlIdx{ORDER BY!DESC}.
\sqlilIdx{ORDER BY} sorts the rows of the query result by the fields listed afterwards.
If just write \sqlilIdx{ORDER BY} or, optionally, add \sqlil{ASC}\sqlIdx{ORDER BY!ASC}, then it sorts the data in ascending order.
This means that small values coming first.
We want a descending order, so we also write~\sqlil{DESC}\sqlIdx{ORDER BY!DESC}.

Finally, we may realize that there are still way to many entries returned.
We only care about the best five or so deals, the rest does not matter anyway.
All we have to do to limit the number of rows returned to five is to, well, add~\sqlil{LIMIT 5}\sqlIdx{LIMIT} to our query.
With this, the query is completed.
It is the second one in \cref{lst:factory:select_from_table_product}.

Its result in \cref{exec:factory:select_from_table_product} shows us that the large purse is definitely the best deal here.
For every single~元, we can get 10g of product!
Indeed, the purse weights 1.5kg and costs 150元, so the result is correct.
The second-best deal would be the largest shoe in stock.
At size~43, we can 8.94g of product per~元.

What else can we find out about the data in this table?
What if we wanted to know whether shoes or purses costed more on average?
First, let's figure out how to compute arithmetic means in \sql.
It is rather easy.
We could write \sqlil{SELECT AVG(price) FROM product;}\sqlIdx{AVG} to get the arithmetic mean over all values in the column \sqlil{price} in the table \sqlil{product}~\cite{PGDG:PD:AF}.
This query would return a single row with a single value named \sqlil{avg}.
That value would be \sqlil{148.5381818181818182} if you want to try it by yourself.

Let's give the value a better name.
Let's try \sqlil{SELECT AVG(price) AS mean_price FROM product;}\sqlIdx{AVG}
The result would still be pretty much the same, but now the returned column is named~\sqlil{mean_price}~(and there still only a single row).%
%
\begin{sloppypar}%
As the next step, let's compute the average price for purses.
We can reuse the condition \sqlil{WHERE name LIKE '\%Purse\%'} from before and write \sqlil{SELECT AVG(price) AS mean_price FROM product WHERE name LIKE '\%Purse\%';}
This returns a single column named \sqlil{mean_price} and a single row.
The value in that row is now \sqlil{123.3333333333333333}, which indeed is the arithmetic mean of 100, 120, and~150.
To make clear that this is the purse price, we can simply add an artificial column named~\sqlil{kind} with value~\sqlil{'Purse'}.
\sqlil{SELECT 'Purse' AS kind, AVG(price) AS mean_price FROM product WHERE name LIKE '\%Purse\%';}.
Now we got two columns, \sqlil{kind} and \sqlil{mean_price}, and one row with the values \textil{Purse} and \sqlil{123.3333333333333333}.%
\end{sloppypar}%
%
\begin{sloppypar}%
We can, of course, do the same for shoes.
All we have to do is to replace \sqlil{'\%Purse\%'} with \sqlil{'\%Shoe\%'} and change the \sqlil{kind} column accordingly.
\sqlil{SELECT 'Shoe' AS kind, AVG(price) AS mean_price FROM product WHERE name LIKE '\%Shoe\%';} returns also a single row with values \textil{Shoe} and \textil{157.9900000000000000}.
Indeed, the average price of all of our shoes is 157.99元.%
\end{sloppypar}%
%
So we have two queries that each return two values with the same names.
At this point, we already know that purses are cheaper than shoes in average.
But having two queries is somehow unsatisfying.
We want to package both results together, so that we get the two rows as the result of a single \sql\ command.

Nothing easier than that!
We just have to remove the trailing~\sqlil{;} from the first query and write a \sqlilIdx{UNION ALL} directly in front of the second query~\cite{PGDG:PD:CQUIE}!
The \sqlilIdx{UNION ALL} statement effectively appends the results of the second query to the results of the first query.
The combined statement is shown at the bottom of \cref{lst:factory:select_from_table_product} and its result is given in \cref{exec:factory:select_from_table_product}.

At this point, please notice the beauty of queries:
We can continue to add data to our table.
We can change values or delete values.
But the queries will still work all the same and always give us the up-to-date results.%
\endhsection%
\FloatBarrier%
\endhsection%
%
\hsection{The Table \inQuotes{customer}}%%
\label{sec:factory:table:customer}%
Next, we design a table for managing customer data.%
%
\hsection{Creating the Table}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_table_customer.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_table_customer}{%
Creating the table \textil{customer} to store the information about our factory's customers.%
}%
%
\begin{sloppypar}%
We create the table \sqlil{customer} using the \sqlil{CREATE TABLE}\sqlIdx{CREATE!TABLE} command in \cref{lst:factory:create_table_customer}.
The first column again should be the primary key~\sqlil{id}, which we again define as \sqlil{INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY}\sqlIdx{INT}\sqlIdx{GENERATED}\sqlIdx{BY DEFAULT}\sqlIdx{PRIMARY KEY}\sqlIdx{IDENTITY}.
\end{sloppypar}%
%
Customers have names, so we again need a \sqlil{name} column.
Names can have different length, but 100~characters seems to be a reasonable limit.
Therefore, we will again use \sqlil{VARCHAR(100)}\sqlIdx{VARCHAR}.
For each customer, a name must be specified, so we again also write \sqlilIdx{NOT NULL}.
Do names need to be unique?
No they don't.
There can easily be two different customers with the same name.
Therefore, we will \emph{not} require this column to be \sqlilIdx{UNIQUE}.

However, when thinking about names, we realize that \sqlilIdx{NOT NULL} is not really a good bottom line for valid names.
Actually, if we go back to our previous table \sqlil{product}, we find that we could easily enter a product with the name \sqlil{' bla     blab  '}, \sqlil{' '}, or even an empty name~\sqlil{''}.
We just demanded that the name be set, not that it cannot be empty.
What would be a good bottom line for valid names?
Well, it should probably start with a \inQuotes{word character}, say, \inQuotes{A}, \inQuotes{b}, or even~\inQuotes{张} and end with one.
Inbetween, we would allow arbitrary characters.
This does not prevent anybody from entering \inQuotes{sgjw9345 s熊猫fki345Q} as name, but at least we would prevent the user from accidentally entering leading or trailing space characters or entering an empty name.
How can we accomplish that?%
%
\begin{sloppypar}%
\sql\ offers the mechanism of \emph{constraints}~\cite{PGDG:PD:C}.
Actually, \sqlilIdx{NOT NULL} and \sqlilIdx{UNIQUE} are shorthands for two constraints.
But we can also define more fancy ones.
Constraints can be written directly after declaring the columns in the \sqlil{CREATE TABLE}\sqlIdx{CREATE!TABLE} command.
The syntax for this is \sqlil{CONSTRAINT constraint_name CHECK (expression)}\sqlIdx{CONSTRAINT!CHECK}.
In other words, we give the constraint a name and provide an expression that should be checked whenever data is entered or changed in the table.
Only if the expression is \sqlilIdx{TRUE} the insertion or change is permitted.%
\end{sloppypar}%
%
This means that we have to figure out how we can define \inQuotes{\sqlil{name} must start and end with a \inQuotes{word character} and can have arbitrary characters inbetween.} as such an expression.
This is a bit beyond what we can do with \sqlilIdx{LIKE}.
Luckily, \pglspl{regex} come to the rescue.
\Pglspl{regex} are text patterns that can be matched against text strings.
They are supported by many tools and programming languages~(such as \python~\cite{programmingWithPython}), and also by \sql\ and, hence, \postgresql~\cite{PGDG:PD:PRE}.
\Pglspl{regex} are a whole different kind of subject that you can read about in~\cite{PGDG:PD:PRE}.
Here we will just briefly introduce and directly use them.

For the \sqlil{name} column, we will use the \pgls{regex} \sqlil{'^\\w.*\\w\$'}.
The \textil{^} matches the beginning of a text, \textil{\\w} stands for a single \inQuotes{word character}, \textil{.} matches to any single character, \textil{*} means that the expression item directly before the \textil{*} can occur any number of times, from zero to infinity, and the \textil{\$} matches to the end of the text.
In other words, we say:
The beginning of the text, i.e., the very first character, must be a \inQuotes{word character}, e.g., \inQuotes{A}, \inQuotes{b}, or \inQuotes{李}.
Then, there can be an arbitrary number of other characters, including spaces, numbers, signs, whatever.
At the end of the text, we again demand a word character.
This means that we demand that names consist of at least two word characters.
We could refine this to also allow single-character names, to prevent characters such as \inQuotes{@} from occurring, etc., but let's keep it at this for now.%
%
\begin{sloppypar}%
Having a reasonable limitation for the name, we now define the rule \sqlil{customer_name_ok} as \sqlil{CONSTRAINT customer_name_ok CHECK (name \~ '^\\w.*\\w\$')}\sqlIdx{{\textbackslash}w}\sqlIdx{\$}\sqlIdx{\textasciicircum}\sqlIdx{.}\sqlIdx{\textasciitilde}.
The \sqlilIdx{CONSTRAINT} marks the beginning of a constraint, \sqlil{customer_name_ok} is the name, and \sqlil{CHECK}\sqlIdx{CONSTRAINT!CHECK} tell us that we will next define an expression~(as opposed to simply \sqlilIdx{NOT NULL}).
\sqlil{(name \~ '^\w.*\w\$')}\sqlIdx{{\textbackslash}w}\sqlIdx{\$}\sqlIdx{\textasciicircum}\sqlIdx{.}\sqlIdx{\textasciitilde} says that the field \sqlil{name} must match the \pgls{regex} \sqlil{'^\\w.*\\w\$'}.
Here, \sqlil{\~}\sqlIdx{\textasciitilde} stands for \pgls{regex}-based pattern matching.
With this, the names \inQuotes{S} and \inQuotes{  schwipschawp } are prohibited, but \inQuotes{Thomas Weise} and \inQuotes{熊猫先生} are OK.%
\end{sloppypar}%
%
Each customer also needs to have a phone number, so we add a column~\sqlil{phone}.
While phone numbers may appear to be integer numbers, they could have leading zeros.
Therefore, we will store them as text strings.
In China, landlines have 10~digits and mobile numbers have 11~digits~\cite{BD2006BDBK:MPNANSBTTMDFMP}.
Therefore, we choose~\sqlil{VARCHAR(11)}\sqlIdx{VARCHAR} as the datatype.
The phone numbers must be~\sqlilIdx{NOT NULL} and this time, we also insist on them to be~\sqlilIdx{UNIQUE}.
While there might be two different customers with the same name, we do not permit two different customers having the same phone number.
Indeed, if our sales department wants to enter a customer's information into the \db\ and there is already one record with the same phone number, then most likely this would be the same customer and they are in the process of creating a duplicate entry by accident.

Now we want to limit the phone number text to represent valid phone numbers.
\sqlil{'ABC'}, for example, is not a valid phone number and neither is~\sqlil{1}.
We want to only permit numbers consisting of ten to eleven digits.
We can do this in exactly the same way in which guarded our \sqlil{name} field:
by defining a constraint.
We write \sqlil{CONSTRAINT customer_phone_ok CHECK (phone ~ '^\d\{10,11\}\$')}\sqlIdx{CONSTRAINT!CHECK}\sqlIdx{{\textbackslash}d}\sqlIdx{\$}\sqlIdx{\textasciicircum}\sqlIdx{\textasciitilde}.
The name of the constraint will be \sqlil{customer_phone_ok}.
We again match a \pgls{regex} via \sqlIdx{\textasciitilde}\sqlil{\~}, but this time we match the value of~\sqlil{phone}.

The \pgls{regex} \sqlil{'\^\\d\{10,11\}\$'}\sqlIdx{{\textbackslash}d}\sqlIdx{\$}\sqlIdx{\textasciicircum} reads as follows:
At the start of the text~(denoted by~\textil{\^}\sqlIdx{\textasciicircum}), there is a sequence of 10 to~11 digits, and then comes the end of the text~(denoted by~\textil{\$}\sqlIdx{\$}).
Here, \textil{\\d}\sqlIdx{{\textbackslash}d}\ stands for a single character that is a digit.
The \textil{\{10,11\}} specfies between 10 and 11 repetitions of this pattern.
Therefore, our constraint requires that any value of \sqlil{phone} to be stored consists of ten to eleven digits~(and only digits).
This rules out phone numbers containing other characters, as well as customers registering under number~110.

Finally, each customer should have a shipping address.
Here we will just settle for \sqlil{VARCHAR(255)}.
A length of at most 255~characters seems reasonable, as 255~is also used in many other systems as the limit.
We require the \sqlil{address} to be \sqlilIdx{NOT NULL}, but it does \emph{not} have to be \sqlilIdx{UNIQUE}.
For laziness sake I will not specify a \sqlilIdx{CONSTRAINT} that sanity-checks addresses {\dots} maybe you could do this as a small exercise when reproducing the example?

Either way, the full \sql\ command for creating our table \sqlil{customer} is given in \cref{lst:factory:create_table_customer}.
Notice that we, again, use the \textil{boss} user with password \textil{superboss123} to execute these commands.
We create the table and, afterwards, check whether a new table appeared in the \sqlilIdx{pg\_catalog.pg\_tables}.
It does: the user \textil{boss} now owns two tables, \sqlil{product} and \sqlil{customer}, as you can see in \cref{exec:factory:create_table_customer}.%
%
\endhsection%
%
\hsection{Inserting some Data}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_customer.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_customer}{%
Storing some customer records in the table \textil{customer}.%
}%
%
We now enter the data of the four (imaginary) customers of our company.
We can do this again with the \sqlilIdx{INSERT INTO} command.
We first need to specify the table, which is \sqlil{customer}, and then the columns, namely \sqlil{name}, \sqlil{phone}, and \sqlil{address}.
We do not need to provide values for the \sqlil{id} column, because it will automatically be set.
The customer names are Bibbo, Bebbo, Bebba, and Bobbo.
Bibbo lives in the south campus of our Hefei University~(合肥大学), Bebbo lives in the town hall of Chemnitz city in Germany, Bebba lives on Times Square in New York, and Bobbo resides on top of the Eiffel Tower in Paris, France.
Their phone numbers are similarly probable.
Either way, we can insert these values by specifying them row-for-row, using commas to separate rows.
Each row is given in parentheses and the values are listed in the same sequence as we specified the columns and separated by comas as well.

\Cref{lst:factory:insert_into_table_customer} and the corresponding \psql\ output in \cref{exec:factory:insert_into_table_customer} show that, first, the table is empty.
\sqlil{SELECT * from customer;} yields 0~rows.
Then we execute the \sqlilIdx{INSERT INTO} command.
Afterwards \sqlil{SELECT * from customer;} prints the four expected rows.%
\endhsection%
%
\hsection{Selecting Data}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{select_from_table_customer.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:select_from_table_customer}{%
Obtaining information from our new table~\sqlil{customer}.%
}%
%
Let us complete this exercise by extracting some data from the new table~\sqlil{customer} in \cref{lst:factory:select_from_table_customer}.
First, we want to have a list of all customers from France.
This can be done with the query \sqlil{SELECT name, address FROM customer WHERE address LIKE '\%France\%';}\sqlIdx{LIKE}\sqlIdx{WHERE}\sqlIdx{SELECT{\idxdots}FROM}
The query prints the \sqlil{name} and \sqlil{address} of all customers whose \sqlil{address} field contains, somewhere, the text~\textil{France}.

Next, we want to know how many domestic Chinese customers we have and how many customers purchase our products from abroad, i.e., not from China.
We first need to decide whether a customer is based in China or not.
We can do this by \sqlil{address ILIKE '\%china\%' as domestic}\sqlIdx{ILIKE}.
Notice that we this time wrote \sqlilIdx{ILIKE} instead of \sqlilIdx{LIKE}.
\sqlilIdx{ILIKE} works basically the same as \sqlilIdx{LIKE}, with the exception that it compares text case-insensitive.
For \sqlilIdx{LIKE}, \textil{China} and \textil{china} are two different strings.
For \sqlilIdx{ILIKE}, they are the same.
By writing \sqlil{SELECT address ILIKE '\%china\%' as domestic from customer;}, we would get a one-column result which contains the value \sqlilIdx{TRUE} for every customer from China and \sqlilIdx{FALSE} for every customer from abroad.%
%
\begin{sloppypar}%
We can now divide the customers into groups based on this column \sqlil{domestic} by adding \sqlil{GROUP BY domestic}\sqlIdx{GROUP BY} to the query.
We count the number of customers in each group by also selecting the new value \sqlil{COUNT(*)}\sqlIdx{COUNT}.
\sqlil{COUNT(*)}\sqlIdx{COUNT} counts the rows in the current group and returns the result as integer number.
The complete query is \sqlil{SELECT COUNT(*), address ILIKE '\%china\%' as domestic FROM customer GROUP BY domestic;}.
It produces two rows.
The first row has \sqlil{domestic} as \sqlil{f}, which means \sqlilIdx{FALSE}.
In its \sqlil{count} column, we see the value~3.
The second row has \sqlil{domestic} as \sqlil{t}, which means \sqlilIdx{TRUE}.
In its \sqlil{count} column, we see the value~1.
Indeed, there are three foreign customers and one domestic one in our \db.%
\end{sloppypar}%
%
If you looked at this example carefully, then you noticed that the method of deciding whether a customer is from China or not, as well as the method of detecting french customers, are not very precise.
For example, if a customer would have specified their country as 中国, i.e., China written in Chinese, we would have considered them a foreigner.
Then again, if the director of the imaginary \emph{Donut Factory Vive la France} in Shanghai would order shoes from us, we would consider his address to be french and domestic at the same time.
Maybe we should have had another column \sqlil{country}?
In this case, we would most likely need a table with countries and link that table to our \sqlil{customer} table\dots
Next, we will explore how tables can be \inQuotes{linked} together.%
%
\endhsection%
\FloatBarrier%
\endhsection%
%
\hsection{The Table \inQuotes{demand}}%%
\label{sec:factory:demand}%
We now have two tables.
In the first table, we have the products that we can sell.
In the second table, we have a list of customers.
Now we want to store the actual orders, the sales of our company:
A customer can buy a certain amount of one product.%
%
\hsection{Creating the Table}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{create_table_demand.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:create_table_demand}{%
Creating the table \textil{demand} to store the orders of our customers.%
}%
%
Naturally, we would like to call this table, which stores orders, something like~\sqlil{order}~(as we always use singular table names as stated in \cref{bp:tableName}).
Unfortunately, we already learned that \sqlil{ORDER}\sqlIdx{ORDER BY} is a reserved keyword in \sql.%
%
\bestPractice{neverUseKeywordsAsNames}{%
Never use \sql\ keywords or reserved words as names, e.g., for columns or tables~\cite{B2025DS:SBPASG}.%
}%
%
OK, fine, so we go with a synonym and call the table~\sqlil{demand} in \cref{lst:factory:create_table_demand}.
Like in the other two tables, each demand record must have a unique primary key~\sqlil{id}.
This should be an integer number which is automatically generated by the \db\ for us.
Therefore, we define the column \sqlil{id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY}\sqlIdx{INT}\sqlIdx{GENERATED}\sqlIdx{BY DEFAULT}\sqlIdx{PRIMARY KEY}\sqlIdx{IDENTITY}, in the same way we already did before.

Now, however, comes something really cool:
Only customers can make orders.
Therefore, every record in the table \sqlil{demand} must be linked to exactly one record in the table \sqlil{customer}.
How can we do that?
Via so-called \emph{foreign keys}~\cite{PGDG:PD:FK}.
You see, in both of our existing tables, we have defined a \sqlilIdx{PRIMARY KEY}.
We used auto-generated integers, as we also do in the new table.
We can now define a column which also is of type \sqlilIdx{INT} and that references the primary key of another table.

We can write \sqlil{customer INT NOT NULL REFERENCES customer(id)}\sqlIdx{REFERENCES} to define such a file.
The name of this new column in our table \sqlil{demand} will be \sqlil{customer}.
We declare it as an \sqlilIdx{INT} which must be \sqlilIdx{NOT NULL}.
Now we write \sqlil{REFERENCES customer(id)}\sqlIdx{REFERENCES}, which basically is a constraint.
This constraint is called \emph{foreign key}.
For any value of \sqlil{customer} in our new table, makes sure that there \emph{always} is a row in table \sqlil{customer} whose \sqlil{id}~value is the same.
You cannot add a row to our table \sqlil{demand} if the \sqlil{customer} value does not match to an \sqlil{id} of one row in table~\sqlil{customer}.
You also cannot delete a record from \sqlil{customer} if its \sqlil{id} is used somewhere in table~\sqlil{demand}.
This means every single record in our table \sqlil{demand} will definitely be linked to one record in table~\sqlil{customer}.
Of course, a record in table \sqlil{customer} can be linked to many records in table~\sqlil{demand}.

Now, the customer makes a purchase.
So we want to link this purchase also to a product.
For the sake of simplicity, we only allow the customer to purchase one product at a time.
Otherwise we need yet another table {\dots} and this example will get too exhausting.
So after linking the demand records to customer records, we also need to link them to product records.
We therefore add another column that we will call \sqlil{product} by writing \sqlil{product INT NOT NULL REFERENCES product(id)}\sqlIdx{INT}\sqlIdx{NOT NULL}\sqlIdx{REFERENCES}.
As you can see, we again mark this column as foreign key by specifying a \sqlil{REFERENCES} constraint.
This time, it references the column~\sqlil{id} of table~\sqlil{product}.
In other words, every single record that we will put into the table~\sqlil{demand} will be linked to exactly one record in table~\sqlil{customer} and to exactly one record in table~\sqlil{product}.

So the customer has ordered one product.
Next we want to specify the amount of the product that the customer orders.
We create the column \sqlil{amount INT NOT NULL}\sqlIdx{INT}\sqlIdx{NOT NULL}.
For each demand, we must specify an amount~(\sqlilIdx{NOT NULL}) and that amount must be an integer, hence the~\sqlilIdx{INT}.
Having learned about constraints a while ago, we want to protect our data a bit better.
For example, we want to make sure that \sqlil{amount} is always positive, i.e., greater than zero.
Also, orders for over one million units of any product are unrealistic.
If we are about to insert a record into our \sqlil{demand} table where someone orders a million shoes, chances are that something went wrong.
So we want to define a constraint enforcing \sqlil{amount} to stay in~\intRange{1}{999\decSep999}.

We can write \sqlil{CONSTRAINT ordered_amount_ok CHECK (amount > 0)}\sqlIdx{CONSTRAINT!CHECK}.
This will create the constraint \sqlil{ordered_amount_ok} which will check that \sqlil{amount} is greater than zero.
We can also write \sqlil{CONSTRAINT ordered_amount_ok CHECK (amount < 1000000)}\sqlIdx{CONSTRAINT!CHECK}.
This would instead make sure that the ordered amount is less than one million.
We can combine both conditions into one and simply write \sqlil{CONSTRAINT ordered_amount_ok CHECK ((amount > 0) AND (amount < 1000000))}\sqlIdx{AND}\sqlIdx{CONSTRAINT!CHECK}.
Indeed, \sql\ supports logical operators such as \sqlilIdx{AND}, \sqlilIdx{OR}, and~\sqlilIdx{NOT}.
With this, we prevent any order for less than one or more than~999\decSep999 items.

Of course, we also want to store \emph{when} a customer issued the demand.
For storing dates, \sql\ offers the \sqlilIdx{DATE} type.
It allows us to specify dates in the Gregorian calendar~\cite{PGDG:PD:HU,G1582IG}.
As notation, the ISO standard format~\inQuotes{\textil{YYYY-MM-DD}}~\cite{ISO860112019} is used, where \textil{YYYY} is the four-digits of the year, \textil{MM} stands for the number month in two digits, and \textil{DD} is the day specified with two digits as well.
We then can compare dates and do all sorts of arithmetics with them.
Like the type \sqlilIdx{DECIMAL} being the canonical datatype to be used for monetary things, \sqlilIdx{DATE} is the right type for dates.
It is also a reserved word, so we cannot call our new column \sqlil{date} and we also cannot call it \sqlil{when}, as this is also reserved.
Lets use \sqlil{ordered} as name for the column storing date when the customer ordered our product.
We write \sqlil{ordered DATE NOT NULL} as column definition, because we want to enforce that it is \sqlilIdx{NOT NULL}, i.e., the order date must always be specified.%
%
\begin{sloppypar}%
Let us also insert a sanity check constraint to make sure that dates make sense.
Assume that we built our database in October~2024, then no order with a date before \textil{2024-10-01} can exist.
Furthermore, it would be unlikely that our software was still running in a thousand years, so let's also not except any date greater than or equal to \textil{3000-01-01}.
We write \sqlil{CONSTRAINT ordered_date_ok CHECK ((ordered > '2024-10-01') AND (ordered < '3000-01-01'))}\sqlIdx{CONSTRAINT!CHECK} to combine both constraints.
As you see, arithmetic comparisons have been implemented for the \sqlilIdx{DATE} datatype.%
\end{sloppypar}%
%
The table is created using the completed command in \cref{lst:factory:create_table_demand}.
In \cref{exec:factory:create_table_demand} we see the result -- there is now a new table~\sqlil{demand} in our \db.%
%
\endhsection%
%
\hsection{Inserting some Data}%
\gitSQLAndOutput{\databasesCodeRepo}{factory}{insert_into_table_demand.sql}{factory}{boss}{superboss123}{postgres.sh}{factory:insert_into_table_demand}{%
Storing some order records in the table \textil{demand}.%
}%
%
Inserting data into our new table~\sqlil{demand}, however, is a bit annoying.
We need to refer to the customers and the products by their~\sqlil{id}.
In \cref{lst:factory:insert_into_table_demand}, we use an \sqlilIdx{INSERT INTO} command to insert eight orders into the table.
We need to specify the value of \sqlil{customer}, \sqlil{product}, \sqlil{amount}, and the \sqlil{ordered} date for each of them.
The first row is \sqlil{(1, 7, 12, '2024-11-21')}.
It means that customer~1, namely Mr.~Bibbo orders twelve units of product~7, i.e., \inQuotes{Shoe, Size 42.}
He did this on November~21, 2024.
The second row is \sqlil{(2, 3, 2, '2024-12-09')}, meaning that customer~2, i.e., Mr.~Bebbo, ordered 2~units of product~3, namely \inQuotes{Shoe, Size 38.}
This happened on December~9, 2024.
We insert several rows like this.
For instance, row \sqlil{(3, 11, 10, '2025-01-16')} identifies Mrs.~Bebba~(customer~3) as the purchaser of ten large purses~(product~11) on January~16, 2025.

\Cref{lst:factory:insert_into_table_demand} shows the effect of this command.
Querying \sqlil{SELECT * FROM demand;}\sqlIdx{SELECT{\idxdots}FROM} will show us all the rows of this table.
Making sense of this data is, however, not straightforward.
Luckily, \sql\ does not just offer us the ability to link records between tables in order to maintain data integrity.
It also provides us means to connect the information from different tables together.%
%
\endhsection%
\FloatBarrier%
\endhsection%
\endhsection%
%
